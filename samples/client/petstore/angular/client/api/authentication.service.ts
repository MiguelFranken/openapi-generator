/**
 * Stubi Backend REST Documentation
 * This page contains the documentation of the backend of Stubi.<h2>Repositories</h2><ul><li><a href=\"https://github.com/IT4Kids/stubi\">Stubi Frontend</a></li><li><a href=\"https://github.com/IT4Kids/stubi-backend\">Stubi Backend</a></li></ul><h2>Authentication</h2>Most of the endpoints are not public and need a proper authentication. The following is a list of tokens that can be used for testing purposes in this documentation. It is important that you use the whole token including the string \"Bearer\". Click on \"Authorize\" in the upper right corner and copy one of these tokens to authenticateyourself. All subsequent requests will then be sent together with this token.<h3>Tokens</h3><ul><li style=\"overflow-wrap: break-word;\">Admin Token: Bearer eyJhbGciOiJIUzUxMiJ9.eyJzdWIiOiJhZG1pbiIsImV4cCI6MTY0ODM5NTI5OX0.6M2JFiexb08iNF1D1Mj1MGw0Brqr3Kz7QWbobMW4pDQnjVfgjU7JHZ4Pkba2JINIg0CuiJBYzOfhpyo679CODg</li><li style=\"overflow-wrap: break-word;\">User Token: Bearer eyJhbGciOiJIUzUxMiJ9.eyJzdWIiOiJ1c2VyIiwiZXhwIjoxNjQ4Mzk0ODg0fQ.VkIApvDlHToVDa4CNjHi-I_SZ1HdYOQv3T0-iC-o-O4U3uYqUEYX7ZHOMQH2jATb3Z_Pycqp9K-SBKaB5BpAyw</li></ul>
 *
 * The version of the OpenAPI document: 0.0.1-SNAPSHOT
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/* tslint:disable:no-unused-variable member-ordering */

import { Inject, Injectable, Optional }                      from '@angular/core';
import { Logger } from "@upe/logger";
import { HttpClient, HttpHeaders, HttpParams, HttpErrorResponse,
         HttpResponse, HttpEvent, HttpParameterCodec }       from '@angular/common/http';
import { CustomHttpParameterCodec }                          from '../encoder';
import { Observable, throwError, Subject, BehaviorSubject } from 'rxjs';
import { plainToClassFromExist } from "class-transformer";
import { catchError, map, concatMap } from "rxjs/operators";

import { JwtResponseDTO } from '../model/models';
import { MailDTO } from '../model/models';
import { OkDTO } from '../model/models';
import { RefreshTokenDTO } from '../model/models';
import { RegistrationCodeDTO } from '../model/models';
import { RegistrationCodeDevDTO } from '../model/models';

import { BASE_PATH, COLLECTION_FORMATS, HttpImage, IRequestOptions, IRequestOptionsWithResponseType }          from '../variables';
import { Configuration }                                     from '../configuration';

interface LogRequest {
    url: string;
    params?: HttpParams;
    body?: any;
    headers?: HttpHeaders;
}

interface BlobOptions {
    params?: HttpParams | {
        [param: string]: string | string[];
    };
    responseType: "json"; // "blob" as "json"
}


/**
 * @property { RefreshTokenDTO } dto - Used to refresh the authentication token of the user associated with this refresh token
 */
export interface RefreshTokenRequestParams {
    /** Used to refresh the authentication token of the user associated with this refresh token */
    dto: RefreshTokenDTO;
}

/**
 * @property { MailDTO } dto - Used to resend the registration code for the user with the specified mail address by mail
 */
export interface ResendRegistrationCodeRequestParams {
    /** Used to resend the registration code for the user with the specified mail address by mail */
    dto: MailDTO;
}

/**
 * @property { RegistrationCodeDTO } dto - Used to authenticate with a registration code
 */
export interface UseRegistrationCodeRequestParams {
    /** Used to authenticate with a registration code */
    dto: RegistrationCodeDTO;
}

/**
 * @property { string } token - Token to validate with without \&#39;Bearer\&#39; at the beginning. Just the token!
 */
export interface ValidateTokenRequestParams {
    /** Token to validate with without \&#39;Bearer\&#39; at the beginning. Just the token! */
    token: string;
}


/**
  * Endpoints used for developing purposes. Those are deactivated in production environments
  
  */
@Injectable({
  providedIn: 'root'
})
export class AuthenticationService {

    protected basePath = 'http://localhost';
    public defaultHeaders = new HttpHeaders();
    public configuration = new Configuration();
    public encoder: HttpParameterCodec;

    private logger: Logger = new Logger({ name: "AuthenticationService", flags: ["service"] });

    /**
     * Executed when an HTTP error occurred
     */
    private getErrorCallback(request: LogRequest) {
        return (fullHttpErrorResponse: HttpErrorResponse) => {
            const errorDto = fullHttpErrorResponse.error;
            this.logger.error("Error occurred", {
                request,
                error: errorDto
            });
            return throwError(errorDto);
        };
    }

    /**
    * Transforms asynchronously a blob into an image using the file reader
    */
    private createImageFromBlob(image: Blob): Observable<HttpImage> {
        const reader = new FileReader();
        if (image) {
            reader.readAsDataURL(image);
        }
        const subject = new Subject<string | ArrayBuffer>();
        reader.addEventListener("load", () => {
            subject.next(reader.result);
        }, false);
        return subject.asObservable();
    }

    constructor(
      protected httpClient: HttpClient,
      @Optional()@Inject(BASE_PATH) basePath: string,
      @Optional() configuration: BehaviorSubject<Configuration>
    ) {
        if (configuration) {
            configuration.subscribe((configuration) => {
                this.configuration = configuration;
                this.logger.debug("Updated API configuration");
            });
        }
        if (typeof this.configuration.basePath !== 'string') {
            if (typeof basePath !== 'string') {
                basePath = this.basePath;
            }
            this.configuration.basePath = basePath;
        }
        this.encoder = this.configuration.encoder || new CustomHttpParameterCodec();
    }


    private addToHttpParams(httpParams: HttpParams, value: any, key?: string): HttpParams {
        if (typeof value === "object" && value instanceof Date === false) {
            httpParams = this.addToHttpParamsRecursive(httpParams, value);
        } else {
            httpParams = this.addToHttpParamsRecursive(httpParams, value, key);
        }
        return httpParams;
    }

    private addToHttpParamsRecursive(httpParams: HttpParams, value?: any, key?: string): HttpParams {
        if (value == null) {
            return httpParams;
        }

        if (typeof value === "object") {
            if (Array.isArray(value)) {
                (value as any[]).forEach( elem => httpParams = this.addToHttpParamsRecursive(httpParams, elem, key));
            } else if (value instanceof Date) {
                if (key != null) {
                    httpParams = httpParams.append(key,
                        (value as Date).toISOString().substr(0, 10));
                } else {
                   throw Error("key may not be null if value is Date");
                }
            } else {
                Object.keys(value).forEach( k => httpParams = this.addToHttpParamsRecursive(
                    httpParams, value[k], key != null ? `${key}.${k}` : k));
            }
        } else if (key != null) {
            httpParams = httpParams.append(key, value);
        } else {
            throw Error("key may not be null if value is not object or array");
        }
        return httpParams;
    }

    /**
  * Find all active registration code and associated user account pairs
  * <p></p>
  * <p></p>
  * <b>Example Response:</b><br>
  * <pre>
  * {
  "code" : "2808",
  "username" : "miguel.franken"
}
  * </pre>
  * <p></p>
  * <p><b>Possible HTTP Response Statuses:</b>
  * <br>- 200 (OK) with body {@link RegistrationCodeDevDTO}
  * <p></p>
  * @param requestOptions Optional request options
  */

    public findAllRegistrationCodes(requestOptions?: IRequestOptions): Observable<Array<RegistrationCodeDevDTO>>
    /**
  * Find all active registration code and associated user account pairs
  * <p></p>
  * <p></p>
  * <b>Example Response:</b><br>
  * <pre>
  * {
  "code" : "2808",
  "username" : "miguel.franken"
}
  * </pre>
  * <p></p>
  * <p><b>Possible HTTP Response Statuses:</b>
  * <br>- 200 (OK) with body {@link RegistrationCodeDevDTO}
  * <p></p>
  * @param requestOptions Optional request options
  */

    public findAllRegistrationCodes<T>(requestOptions?: IRequestOptionsWithResponseType<T>): Observable<T>
    public findAllRegistrationCodes<T>(requestOptions?: any): Observable<Array<RegistrationCodeDevDTO>> {
        if (!!requestOptions && !!requestOptions.debugging) {
            if (!!requestOptions.responseType) {
                this.logger.debug("Using extended DTO for deserialization");
            } else {
                this.logger.debug("No handwritten DTO extension was registered");
            }
            this.logger.debug("Sending request findAllRegistrationCodes");
        }


        let headers = this.defaultHeaders;

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected  = this.configuration.selectHeaderAccept(httpHeaderAccepts);

        let acceptString = "application/json";
        if (httpHeaderAccepts.length > 0) {
            acceptString = httpHeaderAccepts.join(", ");
            if (httpHeaderAccepts.find((acceptString: string) => acceptString.includes("json")) === undefined) {
                acceptString += ", application/json";
            }
        }
        headers = headers.set('Accept', acceptString);


        let responseType: 'text' | 'json' = 'json';
        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {
            responseType = 'text';
        }
        if(acceptString.includes('image')) {
            responseType = "blob" as "json";
        }


        const httpOptions: any = {
            responseType: <any>responseType,
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: (!!requestOptions && !!requestOptions.observe) ? requestOptions.observe : "body"
        };

        const requestPath = `${this.configuration.basePath}/dev/registration-codes`;

        const logRequest: LogRequest = {
            url: requestPath,
            
            headers
        };

        if (acceptString.includes('image')) {
            return this.httpClient.get<Blob>(requestPath, httpOptions as BlobOptions).pipe(
                concatMap(result => {
                    return this.createImageFromBlob(result);
                }),
                catchError(this.getErrorCallback(logRequest).bind(this))
            );
        } else if (!!requestOptions && !!requestOptions.responseType) {
            const responseObservable = this.httpClient.get<any>(requestPath ,httpOptions).pipe(
                map(response => plainToClassFromExist(new requestOptions.responseType(), response)),
                catchError(this.getErrorCallback(logRequest).bind(this))
            );
            return responseObservable;
        } else {
            return this.httpClient.get<Array<RegistrationCodeDevDTO>>(requestPath, 
                httpOptions
            ).pipe(
                catchError(this.getErrorCallback(logRequest).bind(this))
            );
        }
  }

    /**
  * Refresh the specified token
  * <p></p>
  * <p></p>
  * <b>Example Response:</b><br>
  * <pre>
  * {
  "firstname" : "Miguel",
  "id" : 0,
  "lastname" : "Franken",
  "refreshToken" : "refreshToken",
  "token" : "token",
  "username" : "miguel.franken"
}
  * </pre>
  * <p></p>
  * <p><b>Possible HTTP Response Statuses:</b>
  * <br>- 200 (OK) with body {@link JwtResponseDTO}<br>- 404 (Specified refresh token does not exist)
  * <p></p>
  * @param requestParameters {@link RefreshTokenRequestParams}
  * @param requestOptions Optional request options
  */

    public refreshToken(requestParameters: RefreshTokenRequestParams, requestOptions?: IRequestOptions): Observable<JwtResponseDTO>
    /**
  * Refresh the specified token
  * <p></p>
  * <p></p>
  * <b>Example Response:</b><br>
  * <pre>
  * {
  "firstname" : "Miguel",
  "id" : 0,
  "lastname" : "Franken",
  "refreshToken" : "refreshToken",
  "token" : "token",
  "username" : "miguel.franken"
}
  * </pre>
  * <p></p>
  * <p><b>Possible HTTP Response Statuses:</b>
  * <br>- 200 (OK) with body {@link JwtResponseDTO}<br>- 404 (Specified refresh token does not exist)
  * <p></p>
  * @param requestParameters {@link RefreshTokenRequestParams}
  * @param requestOptions Optional request options
  */

    public refreshToken<T>(requestParameters: RefreshTokenRequestParams, requestOptions?: IRequestOptionsWithResponseType<T>): Observable<T>
    public refreshToken<T>(requestParameters: RefreshTokenRequestParams, requestOptions?: any): Observable<JwtResponseDTO> {
        if (!!requestOptions && !!requestOptions.debugging) {
            if (!!requestOptions.responseType) {
                this.logger.debug("Using extended DTO for deserialization");
            } else {
                this.logger.debug("No handwritten DTO extension was registered");
            }
            this.logger.debug("Sending request refreshToken with parameters", requestParameters);
        }

        const dto = requestParameters.dto;
        if (dto === null || dto === undefined) {
            this.logger.error('Required parameter dto was null or undefined when calling refreshToken.');
            throw new Error('Required parameter dto was null or undefined when calling refreshToken.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected  = this.configuration.selectHeaderAccept(httpHeaderAccepts);

        let acceptString = "application/json";
        if (httpHeaderAccepts.length > 0) {
            acceptString = httpHeaderAccepts.join(", ");
            if (httpHeaderAccepts.find((acceptString: string) => acceptString.includes("json")) === undefined) {
                acceptString += ", application/json";
            }
        }
        headers = headers.set('Accept', acceptString);

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        let responseType: 'text' | 'json' = 'json';
        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {
            responseType = 'text';
        }
        if(acceptString.includes('image')) {
            responseType = "blob" as "json";
        }


        const httpOptions: any = {
            responseType: <any>responseType,
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: (!!requestOptions && !!requestOptions.observe) ? requestOptions.observe : "body"
        };

        const requestPath = `${this.configuration.basePath}/auth/refresh`;

        const logRequest: LogRequest = {
            url: requestPath,
            body: dto,
            headers
        };

        if (acceptString.includes('image')) {
            return this.httpClient.get<Blob>(requestPath, httpOptions as BlobOptions).pipe(
                concatMap(result => {
                    return this.createImageFromBlob(result);
                }),
                catchError(this.getErrorCallback(logRequest).bind(this))
            );
        } else if (!!requestOptions && !!requestOptions.responseType) {
            const responseObservable = this.httpClient.post<any>(requestPath ,dto,httpOptions).pipe(
                map(response => plainToClassFromExist(new requestOptions.responseType(), response)),
                catchError(this.getErrorCallback(logRequest).bind(this))
            );
            return responseObservable;
        } else {
            return this.httpClient.post<JwtResponseDTO>(requestPath, 
            dto,
                httpOptions
            ).pipe(
                catchError(this.getErrorCallback(logRequest).bind(this))
            );
        }
  }

    /**
  * Resend registration code to the user with the specified mail
  * <p></p>
  * <p></p>
  * <b>Example Response:</b><br>
  * <pre>
  * {
  "type" : "OkDTO"
}
  * </pre>
  * <p></p>
  * <p><b>Possible HTTP Response Statuses:</b>
  * <br>- 200 (OK) with body {@link OkDTO}<br>- 404 (User does not exist)
  * <p></p>
  * @param requestParameters {@link ResendRegistrationCodeRequestParams}
  * @param requestOptions Optional request options
  */

    public resendRegistrationCode(requestParameters: ResendRegistrationCodeRequestParams, requestOptions?: IRequestOptions): Observable<OkDTO>
    /**
  * Resend registration code to the user with the specified mail
  * <p></p>
  * <p></p>
  * <b>Example Response:</b><br>
  * <pre>
  * {
  "type" : "OkDTO"
}
  * </pre>
  * <p></p>
  * <p><b>Possible HTTP Response Statuses:</b>
  * <br>- 200 (OK) with body {@link OkDTO}<br>- 404 (User does not exist)
  * <p></p>
  * @param requestParameters {@link ResendRegistrationCodeRequestParams}
  * @param requestOptions Optional request options
  */

    public resendRegistrationCode<T>(requestParameters: ResendRegistrationCodeRequestParams, requestOptions?: IRequestOptionsWithResponseType<T>): Observable<T>
    public resendRegistrationCode<T>(requestParameters: ResendRegistrationCodeRequestParams, requestOptions?: any): Observable<OkDTO> {
        if (!!requestOptions && !!requestOptions.debugging) {
            if (!!requestOptions.responseType) {
                this.logger.debug("Using extended DTO for deserialization");
            } else {
                this.logger.debug("No handwritten DTO extension was registered");
            }
            this.logger.debug("Sending request resendRegistrationCode with parameters", requestParameters);
        }

        const dto = requestParameters.dto;
        if (dto === null || dto === undefined) {
            this.logger.error('Required parameter dto was null or undefined when calling resendRegistrationCode.');
            throw new Error('Required parameter dto was null or undefined when calling resendRegistrationCode.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected  = this.configuration.selectHeaderAccept(httpHeaderAccepts);

        let acceptString = "application/json";
        if (httpHeaderAccepts.length > 0) {
            acceptString = httpHeaderAccepts.join(", ");
            if (httpHeaderAccepts.find((acceptString: string) => acceptString.includes("json")) === undefined) {
                acceptString += ", application/json";
            }
        }
        headers = headers.set('Accept', acceptString);

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        let responseType: 'text' | 'json' = 'json';
        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {
            responseType = 'text';
        }
        if(acceptString.includes('image')) {
            responseType = "blob" as "json";
        }


        const httpOptions: any = {
            responseType: <any>responseType,
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: (!!requestOptions && !!requestOptions.observe) ? requestOptions.observe : "body"
        };

        const requestPath = `${this.configuration.basePath}/registration-code/ask`;

        const logRequest: LogRequest = {
            url: requestPath,
            body: dto,
            headers
        };

        if (acceptString.includes('image')) {
            return this.httpClient.get<Blob>(requestPath, httpOptions as BlobOptions).pipe(
                concatMap(result => {
                    return this.createImageFromBlob(result);
                }),
                catchError(this.getErrorCallback(logRequest).bind(this))
            );
        } else if (!!requestOptions && !!requestOptions.responseType) {
            const responseObservable = this.httpClient.post<any>(requestPath ,dto,httpOptions).pipe(
                map(response => plainToClassFromExist(new requestOptions.responseType(), response)),
                catchError(this.getErrorCallback(logRequest).bind(this))
            );
            return responseObservable;
        } else {
            return this.httpClient.post<OkDTO>(requestPath, 
            dto,
                httpOptions
            ).pipe(
                catchError(this.getErrorCallback(logRequest).bind(this))
            );
        }
  }

    /**
  * Authenticate user with the specified registration code
  * <p></p>
  * <p></p>
  * <b>Example Response:</b><br>
  * <pre>
  * {
  "firstname" : "Miguel",
  "id" : 0,
  "lastname" : "Franken",
  "refreshToken" : "refreshToken",
  "token" : "token",
  "username" : "miguel.franken"
}
  * </pre>
  * <p></p>
  * <p><b>Possible HTTP Response Statuses:</b>
  * <br>- 200 (OK) with body {@link JwtResponseDTO}<br>- 401 (Registration code is expired)<br>- 404 (Registration code does not exist)
  * <p></p>
  * @param requestParameters {@link UseRegistrationCodeRequestParams}
  * @param requestOptions Optional request options
  */

    public useRegistrationCode(requestParameters: UseRegistrationCodeRequestParams, requestOptions?: IRequestOptions): Observable<JwtResponseDTO>
    /**
  * Authenticate user with the specified registration code
  * <p></p>
  * <p></p>
  * <b>Example Response:</b><br>
  * <pre>
  * {
  "firstname" : "Miguel",
  "id" : 0,
  "lastname" : "Franken",
  "refreshToken" : "refreshToken",
  "token" : "token",
  "username" : "miguel.franken"
}
  * </pre>
  * <p></p>
  * <p><b>Possible HTTP Response Statuses:</b>
  * <br>- 200 (OK) with body {@link JwtResponseDTO}<br>- 401 (Registration code is expired)<br>- 404 (Registration code does not exist)
  * <p></p>
  * @param requestParameters {@link UseRegistrationCodeRequestParams}
  * @param requestOptions Optional request options
  */

    public useRegistrationCode<T>(requestParameters: UseRegistrationCodeRequestParams, requestOptions?: IRequestOptionsWithResponseType<T>): Observable<T>
    public useRegistrationCode<T>(requestParameters: UseRegistrationCodeRequestParams, requestOptions?: any): Observable<JwtResponseDTO> {
        if (!!requestOptions && !!requestOptions.debugging) {
            if (!!requestOptions.responseType) {
                this.logger.debug("Using extended DTO for deserialization");
            } else {
                this.logger.debug("No handwritten DTO extension was registered");
            }
            this.logger.debug("Sending request useRegistrationCode with parameters", requestParameters);
        }

        const dto = requestParameters.dto;
        if (dto === null || dto === undefined) {
            this.logger.error('Required parameter dto was null or undefined when calling useRegistrationCode.');
            throw new Error('Required parameter dto was null or undefined when calling useRegistrationCode.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected  = this.configuration.selectHeaderAccept(httpHeaderAccepts);

        let acceptString = "application/json";
        if (httpHeaderAccepts.length > 0) {
            acceptString = httpHeaderAccepts.join(", ");
            if (httpHeaderAccepts.find((acceptString: string) => acceptString.includes("json")) === undefined) {
                acceptString += ", application/json";
            }
        }
        headers = headers.set('Accept', acceptString);

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        let responseType: 'text' | 'json' = 'json';
        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {
            responseType = 'text';
        }
        if(acceptString.includes('image')) {
            responseType = "blob" as "json";
        }


        const httpOptions: any = {
            responseType: <any>responseType,
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: (!!requestOptions && !!requestOptions.observe) ? requestOptions.observe : "body"
        };

        const requestPath = `${this.configuration.basePath}/auth/authenticate`;

        const logRequest: LogRequest = {
            url: requestPath,
            body: dto,
            headers
        };

        if (acceptString.includes('image')) {
            return this.httpClient.get<Blob>(requestPath, httpOptions as BlobOptions).pipe(
                concatMap(result => {
                    return this.createImageFromBlob(result);
                }),
                catchError(this.getErrorCallback(logRequest).bind(this))
            );
        } else if (!!requestOptions && !!requestOptions.responseType) {
            const responseObservable = this.httpClient.post<any>(requestPath ,dto,httpOptions).pipe(
                map(response => plainToClassFromExist(new requestOptions.responseType(), response)),
                catchError(this.getErrorCallback(logRequest).bind(this))
            );
            return responseObservable;
        } else {
            return this.httpClient.post<JwtResponseDTO>(requestPath, 
            dto,
                httpOptions
            ).pipe(
                catchError(this.getErrorCallback(logRequest).bind(this))
            );
        }
  }

    /**
  * Validate the specified token
  * <p></p>
  * <p></p>
  * <b>Example Response:</b><br>
  * <pre>
  * {
  "type" : "OkDTO"
}
  * </pre>
  * <p></p>
  * <p><b>Possible HTTP Response Statuses:</b>
  * <br>- 200 (OK) with body {@link OkDTO}<br>- 401 (User is not authorized)
  * <p></p>
  * @param requestParameters {@link ValidateTokenRequestParams}
  * @param requestOptions Optional request options
  */

    public validateToken(requestParameters: ValidateTokenRequestParams, requestOptions?: IRequestOptions): Observable<OkDTO>
    /**
  * Validate the specified token
  * <p></p>
  * <p></p>
  * <b>Example Response:</b><br>
  * <pre>
  * {
  "type" : "OkDTO"
}
  * </pre>
  * <p></p>
  * <p><b>Possible HTTP Response Statuses:</b>
  * <br>- 200 (OK) with body {@link OkDTO}<br>- 401 (User is not authorized)
  * <p></p>
  * @param requestParameters {@link ValidateTokenRequestParams}
  * @param requestOptions Optional request options
  */

    public validateToken<T>(requestParameters: ValidateTokenRequestParams, requestOptions?: IRequestOptionsWithResponseType<T>): Observable<T>
    public validateToken<T>(requestParameters: ValidateTokenRequestParams, requestOptions?: any): Observable<OkDTO> {
        if (!!requestOptions && !!requestOptions.debugging) {
            if (!!requestOptions.responseType) {
                this.logger.debug("Using extended DTO for deserialization");
            } else {
                this.logger.debug("No handwritten DTO extension was registered");
            }
            this.logger.debug("Sending request validateToken with parameters", requestParameters);
        }

        const token = requestParameters.token;
        if (token === null || token === undefined) {
            this.logger.error('Required parameter token was null or undefined when calling validateToken.');
            throw new Error('Required parameter token was null or undefined when calling validateToken.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected  = this.configuration.selectHeaderAccept(httpHeaderAccepts);

        let acceptString = "application/json";
        if (httpHeaderAccepts.length > 0) {
            acceptString = httpHeaderAccepts.join(", ");
            if (httpHeaderAccepts.find((acceptString: string) => acceptString.includes("json")) === undefined) {
                acceptString += ", application/json";
            }
        }
        headers = headers.set('Accept', acceptString);

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        let responseType: 'text' | 'json' = 'json';
        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {
            responseType = 'text';
        }
        if(acceptString.includes('image')) {
            responseType = "blob" as "json";
        }


        const httpOptions: any = {
            responseType: <any>responseType,
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: (!!requestOptions && !!requestOptions.observe) ? requestOptions.observe : "body"
        };

        const requestPath = `${this.configuration.basePath}/auth/validate`;

        const logRequest: LogRequest = {
            url: requestPath,
            body: token,
            headers
        };

        if (acceptString.includes('image')) {
            return this.httpClient.get<Blob>(requestPath, httpOptions as BlobOptions).pipe(
                concatMap(result => {
                    return this.createImageFromBlob(result);
                }),
                catchError(this.getErrorCallback(logRequest).bind(this))
            );
        } else if (!!requestOptions && !!requestOptions.responseType) {
            const responseObservable = this.httpClient.post<any>(requestPath ,token,httpOptions).pipe(
                map(response => plainToClassFromExist(new requestOptions.responseType(), response)),
                catchError(this.getErrorCallback(logRequest).bind(this))
            );
            return responseObservable;
        } else {
            return this.httpClient.post<OkDTO>(requestPath, 
            token,
                httpOptions
            ).pipe(
                catchError(this.getErrorCallback(logRequest).bind(this))
            );
        }
  }

}
