/**
 * Stubi Backend REST Documentation
 * This page contains the documentation of the backend of Stubi.<h2>Repositories</h2><ul><li><a href=\"https://github.com/IT4Kids/stubi\">Stubi Frontend</a></li><li><a href=\"https://github.com/IT4Kids/stubi-backend\">Stubi Backend</a></li></ul><h2>Authentication</h2>Most of the endpoints are not public and need a proper authentication. The following is a list of tokens that can be used for testing purposes in this documentation. It is important that you use the whole token including the string \"Bearer\". Click on \"Authorize\" in the upper right corner and copy one of these tokens to authenticateyourself. All subsequent requests will then be sent together with this token.<h3>Tokens</h3><ul><li style=\"overflow-wrap: break-word;\">Admin Token: Bearer eyJhbGciOiJIUzUxMiJ9.eyJzdWIiOiJhZG1pbiIsImV4cCI6MTY0ODM5NTI5OX0.6M2JFiexb08iNF1D1Mj1MGw0Brqr3Kz7QWbobMW4pDQnjVfgjU7JHZ4Pkba2JINIg0CuiJBYzOfhpyo679CODg</li><li style=\"overflow-wrap: break-word;\">User Token: Bearer eyJhbGciOiJIUzUxMiJ9.eyJzdWIiOiJ1c2VyIiwiZXhwIjoxNjQ4Mzk0ODg0fQ.VkIApvDlHToVDa4CNjHi-I_SZ1HdYOQv3T0-iC-o-O4U3uYqUEYX7ZHOMQH2jATb3Z_Pycqp9K-SBKaB5BpAyw</li></ul>
 *
 * The version of the OpenAPI document: 0.0.1-SNAPSHOT
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/* tslint:disable:no-unused-variable member-ordering */

import { Inject, Injectable, Optional }                      from '@angular/core';
import { Logger } from "@upe/logger";
import { HttpClient, HttpHeaders, HttpParams, HttpErrorResponse,
         HttpResponse, HttpEvent, HttpParameterCodec }       from '@angular/common/http';
import { CustomHttpParameterCodec }                          from '../encoder';
import { Observable, throwError, Subject } from 'rxjs';
import { plainToClassFromExist } from "class-transformer";
import { catchError, map, concatMap } from "rxjs/operators";

import { FullNewsDTO } from '../model/models';
import { IdDTO } from '../model/models';
import { NewsCreationDTO } from '../model/models';
import { NewsListDTOFullNewsDTO } from '../model/models';
import { NewsListDTONewsDTO } from '../model/models';
import { NewsUpdateDTO } from '../model/models';
import { OkDTO } from '../model/models';
import { SearchDTO } from '../model/models';

import { BASE_PATH, COLLECTION_FORMATS, HttpImage, IRequestOptions, IRequestOptionsWithResponseType }          from '../variables';
import { Configuration }                                     from '../configuration';

interface LogRequest {
    url: string;
    params?: HttpParams;
    body?: any;
    headers?: HttpHeaders;
}

interface BlobOptions {
    params?: HttpParams | {
        [param: string]: string | string[];
    };
    responseType: "json"; // "blob" as "json"
}


/**
 * @property { NewsCreationDTO } dto - Used to create a new news item
 */
export interface CreateNewsItemRequestParams {
    /** Used to create a new news item */
    dto: NewsCreationDTO;
}

/**
 * @property { number } id - The database generated news id
 */
export interface DeleteNewsItemRequestParams {
    /** The database generated news id */
    id: number;
}

/**
 * @property { number | undefined } page - Page Index
 * @property { number | undefined } size - Page Size
 * @property { Array<string> | undefined } sort - Page Multi-Sort: fieldName,(asc|desc)
 */
export interface FindAllActiveNewsRequestParams {
    /** Page Index */
    page?: number;
    /** Page Size */
    size?: number;
    /** Page Multi-Sort: fieldName,(asc|desc) */
    sort?: Array<string>;
}

/**
 * @property { SearchDTO } dto - Used to specify some string to search for in some object that depends on the context
 * @property { number | undefined } page - Page Index
 * @property { number | undefined } size - Page Size
 * @property { Array<string> | undefined } sort - Page Multi-Sort: fieldName,(asc|desc)
 */
export interface FindAllFilteredPagedNewsRequestParams {
    /** Used to specify some string to search for in some object that depends on the context */
    dto: SearchDTO;
    /** Page Index */
    page?: number;
    /** Page Size */
    size?: number;
    /** Page Multi-Sort: fieldName,(asc|desc) */
    sort?: Array<string>;
}

/**
 * @property { number | undefined } page - Page Index
 * @property { number | undefined } size - Page Size
 * @property { Array<string> | undefined } sort - Page Multi-Sort: fieldName,(asc|desc)
 */
export interface FindAllPagedNewsRequestParams {
    /** Page Index */
    page?: number;
    /** Page Size */
    size?: number;
    /** Page Multi-Sort: fieldName,(asc|desc) */
    sort?: Array<string>;
}

/**
 * @property { number } id - The database generated news id
 */
export interface FindNewsItemRequestParams {
    /** The database generated news id */
    id: number;
}

/**
 * @property { number } id - The database generated news id
 * @property { NewsUpdateDTO } dto - Used to update an existing user account
 */
export interface UpdateNewsItemRequestParams {
    /** The database generated news id */
    id: number;
    /** Used to update an existing user account */
    dto: NewsUpdateDTO;
}


/**
  * Endpoints used to retrieve and manipulate news items
  
  */
@Injectable({
  providedIn: 'root'
})
export class NewsService {

    protected basePath = 'http://49.12.40.234:8080';
    public defaultHeaders = new HttpHeaders();
    public configuration = new Configuration();
    public encoder: HttpParameterCodec;

    private logger: Logger = new Logger({ name: "NewsService", flags: ["service"] });

    /**
     * Executed when an HTTP error occurred
     */
    private getErrorCallback(request: LogRequest) {
        return (fullHttpErrorResponse: HttpErrorResponse) => {
            const errorDto = fullHttpErrorResponse.error;
            this.logger.error("Error occurred", {
                request,
                error: errorDto
            });
            return throwError(errorDto);
        };
    }

    /**
    * Transforms asynchronously a blob into an image using the file reader
    */
    private createImageFromBlob(image: Blob): Observable<HttpImage> {
        const reader = new FileReader();
        if (image) {
            reader.readAsDataURL(image);
        }
        const subject = new Subject<string | ArrayBuffer>();
        reader.addEventListener("load", () => {
            subject.next(reader.result);
        }, false);
        return subject.asObservable();
    }

    constructor(
      protected httpClient: HttpClient,
      @Optional()@Inject(BASE_PATH) basePath: string,
      @Optional() configuration: Configuration
    ) {
        if (configuration) {
            this.configuration = configuration;
        }
        if (typeof this.configuration.basePath !== 'string') {
            if (typeof basePath !== 'string') {
                basePath = this.basePath;
            }
            this.configuration.basePath = basePath;
        }
        this.encoder = this.configuration.encoder || new CustomHttpParameterCodec();
    }


    private addToHttpParams(httpParams: HttpParams, value: any, key?: string): HttpParams {
        if (typeof value === "object" && value instanceof Date === false) {
            httpParams = this.addToHttpParamsRecursive(httpParams, value);
        } else {
            httpParams = this.addToHttpParamsRecursive(httpParams, value, key);
        }
        return httpParams;
    }

    private addToHttpParamsRecursive(httpParams: HttpParams, value?: any, key?: string): HttpParams {
        if (value == null) {
            return httpParams;
        }

        if (typeof value === "object") {
            if (Array.isArray(value)) {
                (value as any[]).forEach( elem => httpParams = this.addToHttpParamsRecursive(httpParams, elem, key));
            } else if (value instanceof Date) {
                if (key != null) {
                    httpParams = httpParams.append(key,
                        (value as Date).toISOString().substr(0, 10));
                } else {
                   throw Error("key may not be null if value is Date");
                }
            } else {
                Object.keys(value).forEach( k => httpParams = this.addToHttpParamsRecursive(
                    httpParams, value[k], key != null ? `${key}.${k}` : k));
            }
        } else if (key != null) {
            httpParams = httpParams.append(key, value);
        } else {
            throw Error("key may not be null if value is not object or array");
        }
        return httpParams;
    }

    /**
  * Add new news item
  * <p></p>
  * <p></p>
  * <b>Security @PreAuthorize expression:</b> <tt>hasRole(\'ADMIN\')</tt>
  * <p></p>
  * <p></p>
  * <b>Example Response:</b><br>
  * <pre>
  * {
  "id" : 0
}
  * </pre>
  * <p></p>
  * <p><b>Possible HTTP Response Statuses:</b>
  * <br>- 200 (OK) with body {@link IdDTO}<br>- 401 (User is not authorized)
  * <p></p>
  * @param requestParameters {@link CreateNewsItemRequestParams}
  * @param requestOptions Optional request options
  */

    public createNewsItem(requestParameters: CreateNewsItemRequestParams, requestOptions?: IRequestOptions): Observable<IdDTO>
    /**
  * Add new news item
  * <p></p>
  * <p></p>
  * <b>Security @PreAuthorize expression:</b> <tt>hasRole(\'ADMIN\')</tt>
  * <p></p>
  * <p></p>
  * <b>Example Response:</b><br>
  * <pre>
  * {
  "id" : 0
}
  * </pre>
  * <p></p>
  * <p><b>Possible HTTP Response Statuses:</b>
  * <br>- 200 (OK) with body {@link IdDTO}<br>- 401 (User is not authorized)
  * <p></p>
  * @param requestParameters {@link CreateNewsItemRequestParams}
  * @param requestOptions Optional request options
  */

    public createNewsItem<T>(requestParameters: CreateNewsItemRequestParams, requestOptions?: IRequestOptionsWithResponseType<T>): Observable<T>
    public createNewsItem<T>(requestParameters: CreateNewsItemRequestParams, requestOptions?: any): Observable<IdDTO> {
        if (!!requestOptions && !!requestOptions.debugging) {
            if (!!requestOptions.responseType) {
                this.logger.debug("Using extended DTO for deserialization");
            } else {
                this.logger.debug("No handwritten DTO extension was registered");
            }
            this.logger.debug("Sending request createNewsItem with parameters", requestParameters);
        }

        const dto = requestParameters.dto;
        if (dto === null || dto === undefined) {
            this.logger.error('Required parameter dto was null or undefined when calling createNewsItem.');
            throw new Error('Required parameter dto was null or undefined when calling createNewsItem.');
        }

        let headers = this.defaultHeaders;

        // authentication (JWT) required
        if (this.configuration.apiKeys) {
            const key: string | undefined = this.configuration.apiKeys()["JWT"] || this.configuration.apiKeys()["Authorization"];
            if (key) {
                headers = headers.set('Authorization', key);
            }
        }
        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected  = this.configuration.selectHeaderAccept(httpHeaderAccepts);

        let acceptString = "application/json";
        if (httpHeaderAccepts.length > 0) {
            acceptString = httpHeaderAccepts.join(", ");
            if (httpHeaderAccepts.find((acceptString: string) => acceptString.includes("json")) === undefined) {
                acceptString += ", application/json";
            }
        }
        headers = headers.set('Accept', acceptString);

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        let responseType: 'text' | 'json' = 'json';
        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {
            responseType = 'text';
        }
        if(acceptString.includes('image')) {
            responseType = "blob" as "json";
        }


        const httpOptions: any = {
            responseType: <any>responseType,
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: (!!requestOptions && !!requestOptions.observe) ? requestOptions.observe : "body"
        };

        const requestPath = `${this.configuration.basePath}/news`;

        const logRequest: LogRequest = {
            url: requestPath,
            body: dto,
            headers
        };

        if (acceptString.includes('image')) {
            return this.httpClient.get<Blob>(requestPath, httpOptions as BlobOptions).pipe(
                concatMap(result => {
                    return this.createImageFromBlob(result);
                }),
                catchError(this.getErrorCallback(logRequest).bind(this))
            );
        } else if (!!requestOptions && !!requestOptions.responseType) {
            const responseObservable = this.httpClient.post<any>(requestPath ,dto,httpOptions).pipe(
                map(response => plainToClassFromExist(new requestOptions.responseType(), response)),
                catchError(this.getErrorCallback(logRequest).bind(this))
            );
            return responseObservable;
        } else {
            return this.httpClient.post<IdDTO>(requestPath, 
            dto,
                httpOptions
            ).pipe(
                catchError(this.getErrorCallback(logRequest).bind(this))
            );
        }
  }

    /**
  * Delete new news item
  * <p></p>
  * <p></p>
  * <b>Security @PreAuthorize expression:</b> <tt>hasRole(\'ADMIN\')</tt>
  * <p></p>
  * <p></p>
  * <b>Example Response:</b><br>
  * <pre>
  * {
  "type" : "OkDTO"
}
  * </pre>
  * <p></p>
  * <p><b>Possible HTTP Response Statuses:</b>
  * <br>- 200 (OK) with body {@link OkDTO}<br>- 401 (User is not authorized)<br>- 404 (News item with the specified id cannot be found)
  * <p></p>
  * @param requestParameters {@link DeleteNewsItemRequestParams}
  * @param requestOptions Optional request options
  */

    public deleteNewsItem(requestParameters: DeleteNewsItemRequestParams, requestOptions?: IRequestOptions): Observable<OkDTO>
    /**
  * Delete new news item
  * <p></p>
  * <p></p>
  * <b>Security @PreAuthorize expression:</b> <tt>hasRole(\'ADMIN\')</tt>
  * <p></p>
  * <p></p>
  * <b>Example Response:</b><br>
  * <pre>
  * {
  "type" : "OkDTO"
}
  * </pre>
  * <p></p>
  * <p><b>Possible HTTP Response Statuses:</b>
  * <br>- 200 (OK) with body {@link OkDTO}<br>- 401 (User is not authorized)<br>- 404 (News item with the specified id cannot be found)
  * <p></p>
  * @param requestParameters {@link DeleteNewsItemRequestParams}
  * @param requestOptions Optional request options
  */

    public deleteNewsItem<T>(requestParameters: DeleteNewsItemRequestParams, requestOptions?: IRequestOptionsWithResponseType<T>): Observable<T>
    public deleteNewsItem<T>(requestParameters: DeleteNewsItemRequestParams, requestOptions?: any): Observable<OkDTO> {
        if (!!requestOptions && !!requestOptions.debugging) {
            if (!!requestOptions.responseType) {
                this.logger.debug("Using extended DTO for deserialization");
            } else {
                this.logger.debug("No handwritten DTO extension was registered");
            }
            this.logger.debug("Sending request deleteNewsItem with parameters", requestParameters);
        }

        const id = requestParameters.id;
        if (id === null || id === undefined) {
            this.logger.error('Required parameter id was null or undefined when calling deleteNewsItem.');
            throw new Error('Required parameter id was null or undefined when calling deleteNewsItem.');
        }

        let headers = this.defaultHeaders;

        // authentication (JWT) required
        if (this.configuration.apiKeys) {
            const key: string | undefined = this.configuration.apiKeys()["JWT"] || this.configuration.apiKeys()["Authorization"];
            if (key) {
                headers = headers.set('Authorization', key);
            }
        }
        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected  = this.configuration.selectHeaderAccept(httpHeaderAccepts);

        let acceptString = "application/json";
        if (httpHeaderAccepts.length > 0) {
            acceptString = httpHeaderAccepts.join(", ");
            if (httpHeaderAccepts.find((acceptString: string) => acceptString.includes("json")) === undefined) {
                acceptString += ", application/json";
            }
        }
        headers = headers.set('Accept', acceptString);


        let responseType: 'text' | 'json' = 'json';
        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {
            responseType = 'text';
        }
        if(acceptString.includes('image')) {
            responseType = "blob" as "json";
        }


        const httpOptions: any = {
            responseType: <any>responseType,
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: (!!requestOptions && !!requestOptions.observe) ? requestOptions.observe : "body"
        };

        const requestPath = `${this.configuration.basePath}/news/${encodeURIComponent(String(id))}`;

        const logRequest: LogRequest = {
            url: requestPath,
            
            headers
        };

        if (acceptString.includes('image')) {
            return this.httpClient.get<Blob>(requestPath, httpOptions as BlobOptions).pipe(
                concatMap(result => {
                    return this.createImageFromBlob(result);
                }),
                catchError(this.getErrorCallback(logRequest).bind(this))
            );
        } else if (!!requestOptions && !!requestOptions.responseType) {
            const responseObservable = this.httpClient.delete<any>(requestPath ,httpOptions).pipe(
                map(response => plainToClassFromExist(new requestOptions.responseType(), response)),
                catchError(this.getErrorCallback(logRequest).bind(this))
            );
            return responseObservable;
        } else {
            return this.httpClient.delete<OkDTO>(requestPath, 
                httpOptions
            ).pipe(
                catchError(this.getErrorCallback(logRequest).bind(this))
            );
        }
  }

    /**
  * Find all active news
  * <p></p>
  * <p></p>
  * <b>Example Response:</b><br>
  * <pre>
  * {
  "news" : [ {
    "createdBy" : "Miguel Franken",
    "link" : "https://it-for-kids.org/blog/2019/12/variablen-und-ihr-zuhause",
    "body" : "Some Example Content",
    "creationDate" : "2000-01-23T04:56:07.000+00:00",
    "title" : "Some Example Title",
    "createdById" : 0
  }, {
    "createdBy" : "Miguel Franken",
    "link" : "https://it-for-kids.org/blog/2019/12/variablen-und-ihr-zuhause",
    "body" : "Some Example Content",
    "creationDate" : "2000-01-23T04:56:07.000+00:00",
    "title" : "Some Example Title",
    "createdById" : 0
  } ],
  "lastPage" : true
}
  * </pre>
  * <p></p>
  * <p><b>Possible HTTP Response Statuses:</b>
  * <br>- 200 (OK) with body {@link NewsListDTONewsDTO}<br>- 401 (User is not authorized)
  * <p></p>
  * @param requestParameters {@link FindAllActiveNewsRequestParams}
  * @param requestOptions Optional request options
  */

    public findAllActiveNews(requestParameters: FindAllActiveNewsRequestParams, requestOptions?: IRequestOptions): Observable<NewsListDTONewsDTO>
    /**
  * Find all active news
  * <p></p>
  * <p></p>
  * <b>Example Response:</b><br>
  * <pre>
  * {
  "news" : [ {
    "createdBy" : "Miguel Franken",
    "link" : "https://it-for-kids.org/blog/2019/12/variablen-und-ihr-zuhause",
    "body" : "Some Example Content",
    "creationDate" : "2000-01-23T04:56:07.000+00:00",
    "title" : "Some Example Title",
    "createdById" : 0
  }, {
    "createdBy" : "Miguel Franken",
    "link" : "https://it-for-kids.org/blog/2019/12/variablen-und-ihr-zuhause",
    "body" : "Some Example Content",
    "creationDate" : "2000-01-23T04:56:07.000+00:00",
    "title" : "Some Example Title",
    "createdById" : 0
  } ],
  "lastPage" : true
}
  * </pre>
  * <p></p>
  * <p><b>Possible HTTP Response Statuses:</b>
  * <br>- 200 (OK) with body {@link NewsListDTONewsDTO}<br>- 401 (User is not authorized)
  * <p></p>
  * @param requestParameters {@link FindAllActiveNewsRequestParams}
  * @param requestOptions Optional request options
  */

    public findAllActiveNews<T>(requestParameters: FindAllActiveNewsRequestParams, requestOptions?: IRequestOptionsWithResponseType<T>): Observable<T>
    public findAllActiveNews<T>(requestParameters: FindAllActiveNewsRequestParams, requestOptions?: any): Observable<NewsListDTONewsDTO> {
        if (!!requestOptions && !!requestOptions.debugging) {
            if (!!requestOptions.responseType) {
                this.logger.debug("Using extended DTO for deserialization");
            } else {
                this.logger.debug("No handwritten DTO extension was registered");
            }
            this.logger.debug("Sending request findAllActiveNews with parameters", requestParameters);
        }

        const page = requestParameters.page;
        const size = requestParameters.size;
        const sort = requestParameters.sort;

        let queryParameters = new HttpParams({encoder: this.encoder});
        if (page !== undefined && page !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>page, 'page');
        }
        if (size !== undefined && size !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>size, 'size');
        }
        if (sort) {
            sort.forEach((element) => {
                queryParameters = this.addToHttpParams(queryParameters,
                  <any>element, 'sort');
            })
        }

        let headers = this.defaultHeaders;

        // authentication (JWT) required
        if (this.configuration.apiKeys) {
            const key: string | undefined = this.configuration.apiKeys()["JWT"] || this.configuration.apiKeys()["Authorization"];
            if (key) {
                headers = headers.set('Authorization', key);
            }
        }
        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected  = this.configuration.selectHeaderAccept(httpHeaderAccepts);

        let acceptString = "application/json";
        if (httpHeaderAccepts.length > 0) {
            acceptString = httpHeaderAccepts.join(", ");
            if (httpHeaderAccepts.find((acceptString: string) => acceptString.includes("json")) === undefined) {
                acceptString += ", application/json";
            }
        }
        headers = headers.set('Accept', acceptString);


        let responseType: 'text' | 'json' = 'json';
        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {
            responseType = 'text';
        }
        if(acceptString.includes('image')) {
            responseType = "blob" as "json";
        }


        const httpOptions: any = {
            params: queryParameters,
            responseType: <any>responseType,
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: (!!requestOptions && !!requestOptions.observe) ? requestOptions.observe : "body"
        };

        const requestPath = `${this.configuration.basePath}/news`;

        const logRequest: LogRequest = {
            url: requestPath,
            
            headers
        };

        if (acceptString.includes('image')) {
            return this.httpClient.get<Blob>(requestPath, httpOptions as BlobOptions).pipe(
                concatMap(result => {
                    return this.createImageFromBlob(result);
                }),
                catchError(this.getErrorCallback(logRequest).bind(this))
            );
        } else if (!!requestOptions && !!requestOptions.responseType) {
            const responseObservable = this.httpClient.get<any>(requestPath ,httpOptions).pipe(
                map(response => plainToClassFromExist(new requestOptions.responseType(), response)),
                catchError(this.getErrorCallback(logRequest).bind(this))
            );
            return responseObservable;
        } else {
            return this.httpClient.get<NewsListDTONewsDTO>(requestPath, 
                httpOptions
            ).pipe(
                catchError(this.getErrorCallback(logRequest).bind(this))
            );
        }
  }

    /**
  * Find all news items that contain the specified string in the title
  * <p></p>
  * <p></p>
  * <b>Security @PreAuthorize expression:</b> <tt>hasRole(\'ADMIN\')</tt>
  * <p></p>
  * <p></p>
  * <b>Example Response:</b><br>
  * <pre>
  * {
  "news" : [ {
    "createdBy" : "Miguel Franken",
    "endDate" : "2000-01-23T04:56:07.000+00:00",
    "link" : "https://it-for-kids.org/blog/2019/12/variablen-und-ihr-zuhause",
    "disabled" : true,
    "id" : 6,
    "body" : "Some Example Content",
    "creationDate" : "2000-01-23T04:56:07.000+00:00",
    "title" : "Some Example Title",
    "createdById" : 0,
    "startDate" : "2000-01-23T04:56:07.000+00:00"
  }, {
    "createdBy" : "Miguel Franken",
    "endDate" : "2000-01-23T04:56:07.000+00:00",
    "link" : "https://it-for-kids.org/blog/2019/12/variablen-und-ihr-zuhause",
    "disabled" : true,
    "id" : 6,
    "body" : "Some Example Content",
    "creationDate" : "2000-01-23T04:56:07.000+00:00",
    "title" : "Some Example Title",
    "createdById" : 0,
    "startDate" : "2000-01-23T04:56:07.000+00:00"
  } ],
  "lastPage" : true
}
  * </pre>
  * <p></p>
  * <p><b>Possible HTTP Response Statuses:</b>
  * <br>- 200 (OK) with body {@link NewsListDTOFullNewsDTO}<br>- 401 (User is not authorized)
  * <p></p>
  * @param requestParameters {@link FindAllFilteredPagedNewsRequestParams}
  * @param requestOptions Optional request options
  */

    public findAllFilteredPagedNews(requestParameters: FindAllFilteredPagedNewsRequestParams, requestOptions?: IRequestOptions): Observable<NewsListDTOFullNewsDTO>
    /**
  * Find all news items that contain the specified string in the title
  * <p></p>
  * <p></p>
  * <b>Security @PreAuthorize expression:</b> <tt>hasRole(\'ADMIN\')</tt>
  * <p></p>
  * <p></p>
  * <b>Example Response:</b><br>
  * <pre>
  * {
  "news" : [ {
    "createdBy" : "Miguel Franken",
    "endDate" : "2000-01-23T04:56:07.000+00:00",
    "link" : "https://it-for-kids.org/blog/2019/12/variablen-und-ihr-zuhause",
    "disabled" : true,
    "id" : 6,
    "body" : "Some Example Content",
    "creationDate" : "2000-01-23T04:56:07.000+00:00",
    "title" : "Some Example Title",
    "createdById" : 0,
    "startDate" : "2000-01-23T04:56:07.000+00:00"
  }, {
    "createdBy" : "Miguel Franken",
    "endDate" : "2000-01-23T04:56:07.000+00:00",
    "link" : "https://it-for-kids.org/blog/2019/12/variablen-und-ihr-zuhause",
    "disabled" : true,
    "id" : 6,
    "body" : "Some Example Content",
    "creationDate" : "2000-01-23T04:56:07.000+00:00",
    "title" : "Some Example Title",
    "createdById" : 0,
    "startDate" : "2000-01-23T04:56:07.000+00:00"
  } ],
  "lastPage" : true
}
  * </pre>
  * <p></p>
  * <p><b>Possible HTTP Response Statuses:</b>
  * <br>- 200 (OK) with body {@link NewsListDTOFullNewsDTO}<br>- 401 (User is not authorized)
  * <p></p>
  * @param requestParameters {@link FindAllFilteredPagedNewsRequestParams}
  * @param requestOptions Optional request options
  */

    public findAllFilteredPagedNews<T>(requestParameters: FindAllFilteredPagedNewsRequestParams, requestOptions?: IRequestOptionsWithResponseType<T>): Observable<T>
    public findAllFilteredPagedNews<T>(requestParameters: FindAllFilteredPagedNewsRequestParams, requestOptions?: any): Observable<NewsListDTOFullNewsDTO> {
        if (!!requestOptions && !!requestOptions.debugging) {
            if (!!requestOptions.responseType) {
                this.logger.debug("Using extended DTO for deserialization");
            } else {
                this.logger.debug("No handwritten DTO extension was registered");
            }
            this.logger.debug("Sending request findAllFilteredPagedNews with parameters", requestParameters);
        }

        const dto = requestParameters.dto;
        if (dto === null || dto === undefined) {
            this.logger.error('Required parameter dto was null or undefined when calling findAllFilteredPagedNews.');
            throw new Error('Required parameter dto was null or undefined when calling findAllFilteredPagedNews.');
        }
        const page = requestParameters.page;
        const size = requestParameters.size;
        const sort = requestParameters.sort;

        let queryParameters = new HttpParams({encoder: this.encoder});
        if (page !== undefined && page !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>page, 'page');
        }
        if (size !== undefined && size !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>size, 'size');
        }
        if (sort) {
            sort.forEach((element) => {
                queryParameters = this.addToHttpParams(queryParameters,
                  <any>element, 'sort');
            })
        }

        let headers = this.defaultHeaders;

        // authentication (JWT) required
        if (this.configuration.apiKeys) {
            const key: string | undefined = this.configuration.apiKeys()["JWT"] || this.configuration.apiKeys()["Authorization"];
            if (key) {
                headers = headers.set('Authorization', key);
            }
        }
        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected  = this.configuration.selectHeaderAccept(httpHeaderAccepts);

        let acceptString = "application/json";
        if (httpHeaderAccepts.length > 0) {
            acceptString = httpHeaderAccepts.join(", ");
            if (httpHeaderAccepts.find((acceptString: string) => acceptString.includes("json")) === undefined) {
                acceptString += ", application/json";
            }
        }
        headers = headers.set('Accept', acceptString);

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        let responseType: 'text' | 'json' = 'json';
        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {
            responseType = 'text';
        }
        if(acceptString.includes('image')) {
            responseType = "blob" as "json";
        }


        const httpOptions: any = {
            params: queryParameters,
            responseType: <any>responseType,
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: (!!requestOptions && !!requestOptions.observe) ? requestOptions.observe : "body"
        };

        const requestPath = `${this.configuration.basePath}/news/filtered`;

        const logRequest: LogRequest = {
            url: requestPath,
            body: dto,
            headers
        };

        if (acceptString.includes('image')) {
            return this.httpClient.get<Blob>(requestPath, httpOptions as BlobOptions).pipe(
                concatMap(result => {
                    return this.createImageFromBlob(result);
                }),
                catchError(this.getErrorCallback(logRequest).bind(this))
            );
        } else if (!!requestOptions && !!requestOptions.responseType) {
            const responseObservable = this.httpClient.post<any>(requestPath ,dto,httpOptions).pipe(
                map(response => plainToClassFromExist(new requestOptions.responseType(), response)),
                catchError(this.getErrorCallback(logRequest).bind(this))
            );
            return responseObservable;
        } else {
            return this.httpClient.post<NewsListDTOFullNewsDTO>(requestPath, 
            dto,
                httpOptions
            ).pipe(
                catchError(this.getErrorCallback(logRequest).bind(this))
            );
        }
  }

    /**
  * Find all news items
  * <p></p>
  * <p></p>
  * <b>Security @PreAuthorize expression:</b> <tt>hasRole(\'ADMIN\')</tt>
  * <p></p>
  * <p></p>
  * <b>Example Response:</b><br>
  * <pre>
  * {
  "news" : [ {
    "createdBy" : "Miguel Franken",
    "endDate" : "2000-01-23T04:56:07.000+00:00",
    "link" : "https://it-for-kids.org/blog/2019/12/variablen-und-ihr-zuhause",
    "disabled" : true,
    "id" : 6,
    "body" : "Some Example Content",
    "creationDate" : "2000-01-23T04:56:07.000+00:00",
    "title" : "Some Example Title",
    "createdById" : 0,
    "startDate" : "2000-01-23T04:56:07.000+00:00"
  }, {
    "createdBy" : "Miguel Franken",
    "endDate" : "2000-01-23T04:56:07.000+00:00",
    "link" : "https://it-for-kids.org/blog/2019/12/variablen-und-ihr-zuhause",
    "disabled" : true,
    "id" : 6,
    "body" : "Some Example Content",
    "creationDate" : "2000-01-23T04:56:07.000+00:00",
    "title" : "Some Example Title",
    "createdById" : 0,
    "startDate" : "2000-01-23T04:56:07.000+00:00"
  } ],
  "lastPage" : true
}
  * </pre>
  * <p></p>
  * <p><b>Possible HTTP Response Statuses:</b>
  * <br>- 200 (OK) with body {@link NewsListDTOFullNewsDTO}<br>- 401 (User is not authorized)
  * <p></p>
  * @param requestParameters {@link FindAllPagedNewsRequestParams}
  * @param requestOptions Optional request options
  */

    public findAllPagedNews(requestParameters: FindAllPagedNewsRequestParams, requestOptions?: IRequestOptions): Observable<NewsListDTOFullNewsDTO>
    /**
  * Find all news items
  * <p></p>
  * <p></p>
  * <b>Security @PreAuthorize expression:</b> <tt>hasRole(\'ADMIN\')</tt>
  * <p></p>
  * <p></p>
  * <b>Example Response:</b><br>
  * <pre>
  * {
  "news" : [ {
    "createdBy" : "Miguel Franken",
    "endDate" : "2000-01-23T04:56:07.000+00:00",
    "link" : "https://it-for-kids.org/blog/2019/12/variablen-und-ihr-zuhause",
    "disabled" : true,
    "id" : 6,
    "body" : "Some Example Content",
    "creationDate" : "2000-01-23T04:56:07.000+00:00",
    "title" : "Some Example Title",
    "createdById" : 0,
    "startDate" : "2000-01-23T04:56:07.000+00:00"
  }, {
    "createdBy" : "Miguel Franken",
    "endDate" : "2000-01-23T04:56:07.000+00:00",
    "link" : "https://it-for-kids.org/blog/2019/12/variablen-und-ihr-zuhause",
    "disabled" : true,
    "id" : 6,
    "body" : "Some Example Content",
    "creationDate" : "2000-01-23T04:56:07.000+00:00",
    "title" : "Some Example Title",
    "createdById" : 0,
    "startDate" : "2000-01-23T04:56:07.000+00:00"
  } ],
  "lastPage" : true
}
  * </pre>
  * <p></p>
  * <p><b>Possible HTTP Response Statuses:</b>
  * <br>- 200 (OK) with body {@link NewsListDTOFullNewsDTO}<br>- 401 (User is not authorized)
  * <p></p>
  * @param requestParameters {@link FindAllPagedNewsRequestParams}
  * @param requestOptions Optional request options
  */

    public findAllPagedNews<T>(requestParameters: FindAllPagedNewsRequestParams, requestOptions?: IRequestOptionsWithResponseType<T>): Observable<T>
    public findAllPagedNews<T>(requestParameters: FindAllPagedNewsRequestParams, requestOptions?: any): Observable<NewsListDTOFullNewsDTO> {
        if (!!requestOptions && !!requestOptions.debugging) {
            if (!!requestOptions.responseType) {
                this.logger.debug("Using extended DTO for deserialization");
            } else {
                this.logger.debug("No handwritten DTO extension was registered");
            }
            this.logger.debug("Sending request findAllPagedNews with parameters", requestParameters);
        }

        const page = requestParameters.page;
        const size = requestParameters.size;
        const sort = requestParameters.sort;

        let queryParameters = new HttpParams({encoder: this.encoder});
        if (page !== undefined && page !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>page, 'page');
        }
        if (size !== undefined && size !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>size, 'size');
        }
        if (sort) {
            sort.forEach((element) => {
                queryParameters = this.addToHttpParams(queryParameters,
                  <any>element, 'sort');
            })
        }

        let headers = this.defaultHeaders;

        // authentication (JWT) required
        if (this.configuration.apiKeys) {
            const key: string | undefined = this.configuration.apiKeys()["JWT"] || this.configuration.apiKeys()["Authorization"];
            if (key) {
                headers = headers.set('Authorization', key);
            }
        }
        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected  = this.configuration.selectHeaderAccept(httpHeaderAccepts);

        let acceptString = "application/json";
        if (httpHeaderAccepts.length > 0) {
            acceptString = httpHeaderAccepts.join(", ");
            if (httpHeaderAccepts.find((acceptString: string) => acceptString.includes("json")) === undefined) {
                acceptString += ", application/json";
            }
        }
        headers = headers.set('Accept', acceptString);


        let responseType: 'text' | 'json' = 'json';
        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {
            responseType = 'text';
        }
        if(acceptString.includes('image')) {
            responseType = "blob" as "json";
        }


        const httpOptions: any = {
            params: queryParameters,
            responseType: <any>responseType,
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: (!!requestOptions && !!requestOptions.observe) ? requestOptions.observe : "body"
        };

        const requestPath = `${this.configuration.basePath}/news/all`;

        const logRequest: LogRequest = {
            url: requestPath,
            
            headers
        };

        if (acceptString.includes('image')) {
            return this.httpClient.get<Blob>(requestPath, httpOptions as BlobOptions).pipe(
                concatMap(result => {
                    return this.createImageFromBlob(result);
                }),
                catchError(this.getErrorCallback(logRequest).bind(this))
            );
        } else if (!!requestOptions && !!requestOptions.responseType) {
            const responseObservable = this.httpClient.get<any>(requestPath ,httpOptions).pipe(
                map(response => plainToClassFromExist(new requestOptions.responseType(), response)),
                catchError(this.getErrorCallback(logRequest).bind(this))
            );
            return responseObservable;
        } else {
            return this.httpClient.get<NewsListDTOFullNewsDTO>(requestPath, 
                httpOptions
            ).pipe(
                catchError(this.getErrorCallback(logRequest).bind(this))
            );
        }
  }

    /**
  * Find news item with specified id
  * <p></p>
  * <p></p>
  * <b>Security @PreAuthorize expression:</b> <tt>hasRole(\'ADMIN\')</tt>
  * <p></p>
  * <p></p>
  * <b>Example Response:</b><br>
  * <pre>
  * {
  "createdBy" : "Miguel Franken",
  "endDate" : "2000-01-23T04:56:07.000+00:00",
  "link" : "https://it-for-kids.org/blog/2019/12/variablen-und-ihr-zuhause",
  "disabled" : true,
  "id" : 6,
  "body" : "Some Example Content",
  "creationDate" : "2000-01-23T04:56:07.000+00:00",
  "title" : "Some Example Title",
  "createdById" : 0,
  "startDate" : "2000-01-23T04:56:07.000+00:00"
}
  * </pre>
  * <p></p>
  * <p><b>Possible HTTP Response Statuses:</b>
  * <br>- 200 (OK) with body {@link FullNewsDTO}<br>- 401 (User is not authorized)<br>- 404 (News item with the specified id cannot be found)
  * <p></p>
  * @param requestParameters {@link FindNewsItemRequestParams}
  * @param requestOptions Optional request options
  */

    public findNewsItem(requestParameters: FindNewsItemRequestParams, requestOptions?: IRequestOptions): Observable<FullNewsDTO>
    /**
  * Find news item with specified id
  * <p></p>
  * <p></p>
  * <b>Security @PreAuthorize expression:</b> <tt>hasRole(\'ADMIN\')</tt>
  * <p></p>
  * <p></p>
  * <b>Example Response:</b><br>
  * <pre>
  * {
  "createdBy" : "Miguel Franken",
  "endDate" : "2000-01-23T04:56:07.000+00:00",
  "link" : "https://it-for-kids.org/blog/2019/12/variablen-und-ihr-zuhause",
  "disabled" : true,
  "id" : 6,
  "body" : "Some Example Content",
  "creationDate" : "2000-01-23T04:56:07.000+00:00",
  "title" : "Some Example Title",
  "createdById" : 0,
  "startDate" : "2000-01-23T04:56:07.000+00:00"
}
  * </pre>
  * <p></p>
  * <p><b>Possible HTTP Response Statuses:</b>
  * <br>- 200 (OK) with body {@link FullNewsDTO}<br>- 401 (User is not authorized)<br>- 404 (News item with the specified id cannot be found)
  * <p></p>
  * @param requestParameters {@link FindNewsItemRequestParams}
  * @param requestOptions Optional request options
  */

    public findNewsItem<T>(requestParameters: FindNewsItemRequestParams, requestOptions?: IRequestOptionsWithResponseType<T>): Observable<T>
    public findNewsItem<T>(requestParameters: FindNewsItemRequestParams, requestOptions?: any): Observable<FullNewsDTO> {
        if (!!requestOptions && !!requestOptions.debugging) {
            if (!!requestOptions.responseType) {
                this.logger.debug("Using extended DTO for deserialization");
            } else {
                this.logger.debug("No handwritten DTO extension was registered");
            }
            this.logger.debug("Sending request findNewsItem with parameters", requestParameters);
        }

        const id = requestParameters.id;
        if (id === null || id === undefined) {
            this.logger.error('Required parameter id was null or undefined when calling findNewsItem.');
            throw new Error('Required parameter id was null or undefined when calling findNewsItem.');
        }

        let headers = this.defaultHeaders;

        // authentication (JWT) required
        if (this.configuration.apiKeys) {
            const key: string | undefined = this.configuration.apiKeys()["JWT"] || this.configuration.apiKeys()["Authorization"];
            if (key) {
                headers = headers.set('Authorization', key);
            }
        }
        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected  = this.configuration.selectHeaderAccept(httpHeaderAccepts);

        let acceptString = "application/json";
        if (httpHeaderAccepts.length > 0) {
            acceptString = httpHeaderAccepts.join(", ");
            if (httpHeaderAccepts.find((acceptString: string) => acceptString.includes("json")) === undefined) {
                acceptString += ", application/json";
            }
        }
        headers = headers.set('Accept', acceptString);


        let responseType: 'text' | 'json' = 'json';
        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {
            responseType = 'text';
        }
        if(acceptString.includes('image')) {
            responseType = "blob" as "json";
        }


        const httpOptions: any = {
            responseType: <any>responseType,
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: (!!requestOptions && !!requestOptions.observe) ? requestOptions.observe : "body"
        };

        const requestPath = `${this.configuration.basePath}/news/${encodeURIComponent(String(id))}`;

        const logRequest: LogRequest = {
            url: requestPath,
            
            headers
        };

        if (acceptString.includes('image')) {
            return this.httpClient.get<Blob>(requestPath, httpOptions as BlobOptions).pipe(
                concatMap(result => {
                    return this.createImageFromBlob(result);
                }),
                catchError(this.getErrorCallback(logRequest).bind(this))
            );
        } else if (!!requestOptions && !!requestOptions.responseType) {
            const responseObservable = this.httpClient.get<any>(requestPath ,httpOptions).pipe(
                map(response => plainToClassFromExist(new requestOptions.responseType(), response)),
                catchError(this.getErrorCallback(logRequest).bind(this))
            );
            return responseObservable;
        } else {
            return this.httpClient.get<FullNewsDTO>(requestPath, 
                httpOptions
            ).pipe(
                catchError(this.getErrorCallback(logRequest).bind(this))
            );
        }
  }

    /**
  * Update the news item with the specified id
  * <p></p>
  * <p></p>
  * <b>Security @PreAuthorize expression:</b> <tt>hasRole(\'ADMIN\')</tt>
  * <p></p>
  * <p></p>
  * <b>Example Response:</b><br>
  * <pre>
  * {
  "type" : "OkDTO"
}
  * </pre>
  * <p></p>
  * <p><b>Possible HTTP Response Statuses:</b>
  * <br>- 200 (OK) with body {@link OkDTO}<br>- 401 (User is not authorized)<br>- 404 (News item with the specified id cannot be found)
  * <p></p>
  * @param requestParameters {@link UpdateNewsItemRequestParams}
  * @param requestOptions Optional request options
  */

    public updateNewsItem(requestParameters: UpdateNewsItemRequestParams, requestOptions?: IRequestOptions): Observable<OkDTO>
    /**
  * Update the news item with the specified id
  * <p></p>
  * <p></p>
  * <b>Security @PreAuthorize expression:</b> <tt>hasRole(\'ADMIN\')</tt>
  * <p></p>
  * <p></p>
  * <b>Example Response:</b><br>
  * <pre>
  * {
  "type" : "OkDTO"
}
  * </pre>
  * <p></p>
  * <p><b>Possible HTTP Response Statuses:</b>
  * <br>- 200 (OK) with body {@link OkDTO}<br>- 401 (User is not authorized)<br>- 404 (News item with the specified id cannot be found)
  * <p></p>
  * @param requestParameters {@link UpdateNewsItemRequestParams}
  * @param requestOptions Optional request options
  */

    public updateNewsItem<T>(requestParameters: UpdateNewsItemRequestParams, requestOptions?: IRequestOptionsWithResponseType<T>): Observable<T>
    public updateNewsItem<T>(requestParameters: UpdateNewsItemRequestParams, requestOptions?: any): Observable<OkDTO> {
        if (!!requestOptions && !!requestOptions.debugging) {
            if (!!requestOptions.responseType) {
                this.logger.debug("Using extended DTO for deserialization");
            } else {
                this.logger.debug("No handwritten DTO extension was registered");
            }
            this.logger.debug("Sending request updateNewsItem with parameters", requestParameters);
        }

        const id = requestParameters.id;
        if (id === null || id === undefined) {
            this.logger.error('Required parameter id was null or undefined when calling updateNewsItem.');
            throw new Error('Required parameter id was null or undefined when calling updateNewsItem.');
        }
        const dto = requestParameters.dto;
        if (dto === null || dto === undefined) {
            this.logger.error('Required parameter dto was null or undefined when calling updateNewsItem.');
            throw new Error('Required parameter dto was null or undefined when calling updateNewsItem.');
        }

        let headers = this.defaultHeaders;

        // authentication (JWT) required
        if (this.configuration.apiKeys) {
            const key: string | undefined = this.configuration.apiKeys()["JWT"] || this.configuration.apiKeys()["Authorization"];
            if (key) {
                headers = headers.set('Authorization', key);
            }
        }
        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected  = this.configuration.selectHeaderAccept(httpHeaderAccepts);

        let acceptString = "application/json";
        if (httpHeaderAccepts.length > 0) {
            acceptString = httpHeaderAccepts.join(", ");
            if (httpHeaderAccepts.find((acceptString: string) => acceptString.includes("json")) === undefined) {
                acceptString += ", application/json";
            }
        }
        headers = headers.set('Accept', acceptString);

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        let responseType: 'text' | 'json' = 'json';
        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {
            responseType = 'text';
        }
        if(acceptString.includes('image')) {
            responseType = "blob" as "json";
        }


        const httpOptions: any = {
            responseType: <any>responseType,
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: (!!requestOptions && !!requestOptions.observe) ? requestOptions.observe : "body"
        };

        const requestPath = `${this.configuration.basePath}/news/${encodeURIComponent(String(id))}`;

        const logRequest: LogRequest = {
            url: requestPath,
            body: dto,
            headers
        };

        if (acceptString.includes('image')) {
            return this.httpClient.get<Blob>(requestPath, httpOptions as BlobOptions).pipe(
                concatMap(result => {
                    return this.createImageFromBlob(result);
                }),
                catchError(this.getErrorCallback(logRequest).bind(this))
            );
        } else if (!!requestOptions && !!requestOptions.responseType) {
            const responseObservable = this.httpClient.put<any>(requestPath ,dto,httpOptions).pipe(
                map(response => plainToClassFromExist(new requestOptions.responseType(), response)),
                catchError(this.getErrorCallback(logRequest).bind(this))
            );
            return responseObservable;
        } else {
            return this.httpClient.put<OkDTO>(requestPath, 
            dto,
                httpOptions
            ).pipe(
                catchError(this.getErrorCallback(logRequest).bind(this))
            );
        }
  }

}
