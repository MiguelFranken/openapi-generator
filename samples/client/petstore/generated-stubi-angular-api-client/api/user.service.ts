/**
 * Stubi Backend REST Documentation
 * This page contains the documentation of the backend of Stubi.<h2>Repositories</h2><ul><li><a href=\"https://github.com/IT4Kids/stubi\">Stubi Frontend</a></li><li><a href=\"https://github.com/IT4Kids/stubi-backend\">Stubi Backend</a></li></ul><h2>Authentication</h2>Most of the endpoints are not public and need a proper authentication. The following is a list of tokens that can be used for testing purposes in this documentation. It is important that you use the whole token including the string \"Bearer\". Click on \"Authorize\" in the upper right corner and copy one of these tokens to authenticateyourself. All subsequent requests will then be sent together with this token.<h3>Tokens</h3><ul><li style=\"overflow-wrap: break-word;\">Admin Token: Bearer eyJhbGciOiJIUzUxMiJ9.eyJzdWIiOiJhZG1pbiIsImV4cCI6MTY0ODM5NTI5OX0.6M2JFiexb08iNF1D1Mj1MGw0Brqr3Kz7QWbobMW4pDQnjVfgjU7JHZ4Pkba2JINIg0CuiJBYzOfhpyo679CODg</li><li style=\"overflow-wrap: break-word;\">User Token: Bearer eyJhbGciOiJIUzUxMiJ9.eyJzdWIiOiJ1c2VyIiwiZXhwIjoxNjQ4Mzk0ODg0fQ.VkIApvDlHToVDa4CNjHi-I_SZ1HdYOQv3T0-iC-o-O4U3uYqUEYX7ZHOMQH2jATb3Z_Pycqp9K-SBKaB5BpAyw</li></ul>
 *
 * The version of the OpenAPI document: 0.0.1-SNAPSHOT
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/* tslint:disable:no-unused-variable member-ordering */

import { Inject, Injectable, Optional }                      from '@angular/core';
import { Logger } from "@upe/logger";
import { HttpClient, HttpHeaders, HttpParams, HttpErrorResponse,
         HttpResponse, HttpEvent, HttpParameterCodec }       from '@angular/common/http';
import { CustomHttpParameterCodec }                          from '../encoder';
import { Observable, throwError, Subject, BehaviorSubject } from 'rxjs';
import { plainToClassFromExist } from "class-transformer";
import { catchError, map, concatMap } from "rxjs/operators";

import { IdDTO } from '../model/models';
import { OkDTO } from '../model/models';
import { UserCreationDTO } from '../model/models';
import { UserListDTO } from '../model/models';

import { BASE_PATH, COLLECTION_FORMATS, HttpImage, IRequestOptions, IRequestOptionsWithResponseType }          from '../variables';
import { Configuration }                                     from '../configuration';

interface LogRequest {
    url: string;
    params?: HttpParams;
    body?: any;
    headers?: HttpHeaders;
}

interface BlobOptions {
    params?: HttpParams | {
        [param: string]: string | string[];
    };
    responseType: "json"; // "blob" as "json"
}


/**
 * @property { UserCreationDTO } dto - Used to create a new news item
 */
export interface CreateUserRequestParams {
    /** Used to create a new news item */
    dto: UserCreationDTO;
}

/**
 * @property { number } id - Database generated id of the user
 */
export interface DeleteUserRequestParams {
    /** Database generated id of the user */
    id: number;
}

/**
 * @property { number } id - Database generated id of the user
 */
export interface DisableUserRequestParams {
    /** Database generated id of the user */
    id: number;
}

/**
 * @property { number } id - Database generated id of the user
 * @property { boolean | undefined } thumbnail - Flag whether or not to request the smaller-sized thumbnail version of the profile image of the user
 */
export interface DownloadProfileImageRequestParams {
    /** Database generated id of the user */
    id: number;
    /** Flag whether or not to request the smaller-sized thumbnail version of the profile image of the user */
    thumbnail?: boolean;
}

/**
 * @property { number } id - Database generated id of the user
 */
export interface EnableUserRequestParams {
    /** Database generated id of the user */
    id: number;
}

/**
 * @property { number } id - Database generated id of the user
 * @property { Blob } image - New profile image for the specified user
 */
export interface UploadProfileImageRequestParams {
    /** Database generated id of the user */
    id: number;
    /** New profile image for the specified user */
    image: Blob;
}


/**
  * Endpoints used to retrieve and manipulate user related objects
  
  */
@Injectable({
  providedIn: 'root'
})
export class UserService {

    protected basePath = 'http://localhost';
    public defaultHeaders = new HttpHeaders();
    public configuration = new Configuration();
    public encoder: HttpParameterCodec;

    private logger: Logger = new Logger({ name: "UserService", flags: ["service"] });

    /**
     * Executed when an HTTP error occurred
     */
    private getErrorCallback(request: LogRequest) {
        return (fullHttpErrorResponse: HttpErrorResponse) => {
            const errorDto = fullHttpErrorResponse.error;
            this.logger.error("Error occurred", {
                request,
                error: errorDto
            });
            return throwError(errorDto);
        };
    }

    /**
    * Transforms asynchronously a blob into an image using the file reader
    */
    private createImageFromBlob(image: Blob): Observable<HttpImage> {
        const reader = new FileReader();
        if (image) {
            reader.readAsDataURL(image);
        }
        const subject = new Subject<string | ArrayBuffer>();
        reader.addEventListener("load", () => {
            subject.next(reader.result);
        }, false);
        return subject.asObservable();
    }

    constructor(
      protected httpClient: HttpClient,
      @Optional()@Inject(BASE_PATH) basePath: string,
      @Optional() configuration: BehaviorSubject<Configuration>
    ) {
        if (configuration) {
            configuration.subscribe((configuration) => {
                this.configuration = configuration;
                this.logger.debug("Updated API configuration");
            });
        }
        if (typeof this.configuration.basePath !== 'string') {
            if (typeof basePath !== 'string') {
                basePath = this.basePath;
            }
            this.configuration.basePath = basePath;
        }
        this.encoder = this.configuration.encoder || new CustomHttpParameterCodec();
    }

    /**
     * @param consumes string[] mime-types
     * @return true: consumes contains 'multipart/form-data', false: otherwise
     */
    private canConsumeForm(consumes: string[]): boolean {
        const form = 'multipart/form-data';
        for (const consume of consumes) {
            if (form === consume) {
                return true;
            }
        }
        return false;
    }

    private addToHttpParams(httpParams: HttpParams, value: any, key?: string): HttpParams {
        if (typeof value === "object" && value instanceof Date === false) {
            httpParams = this.addToHttpParamsRecursive(httpParams, value);
        } else {
            httpParams = this.addToHttpParamsRecursive(httpParams, value, key);
        }
        return httpParams;
    }

    private addToHttpParamsRecursive(httpParams: HttpParams, value?: any, key?: string): HttpParams {
        if (value == null) {
            return httpParams;
        }

        if (typeof value === "object") {
            if (Array.isArray(value)) {
                (value as any[]).forEach( elem => httpParams = this.addToHttpParamsRecursive(httpParams, elem, key));
            } else if (value instanceof Date) {
                if (key != null) {
                    httpParams = httpParams.append(key,
                        (value as Date).toISOString().substr(0, 10));
                } else {
                   throw Error("key may not be null if value is Date");
                }
            } else {
                Object.keys(value).forEach( k => httpParams = this.addToHttpParamsRecursive(
                    httpParams, value[k], key != null ? `${key}.${k}` : k));
            }
        } else if (key != null) {
            httpParams = httpParams.append(key, value);
        } else {
            throw Error("key may not be null if value is not object or array");
        }
        return httpParams;
    }

    /**
  * Create new user
  * <p></p>
  * <p></p>
  * <b>Security @PreAuthorize expression:</b> <tt>hasRole(\'ADMIN\')</tt>
  * <p></p>
  * <p></p>
  * <b>Example Response:</b><br>
  * <pre>
  * {
  "id" : 0
}
  * </pre>
  * <p></p>
  * <p><b>Possible HTTP Response Statuses:</b>
  * <br>- 200 (OK) with body {@link IdDTO}<br>- 401 (User is not authorized)<br>- 409 (User cannot be added to database as user with the specified name already exists)
  * <p></p>
  * @param requestParameters {@link CreateUserRequestParams}
  * @param requestOptions Optional request options
  */

    public createUser(requestParameters: CreateUserRequestParams, requestOptions?: IRequestOptions): Observable<IdDTO>
    /**
  * Create new user
  * <p></p>
  * <p></p>
  * <b>Security @PreAuthorize expression:</b> <tt>hasRole(\'ADMIN\')</tt>
  * <p></p>
  * <p></p>
  * <b>Example Response:</b><br>
  * <pre>
  * {
  "id" : 0
}
  * </pre>
  * <p></p>
  * <p><b>Possible HTTP Response Statuses:</b>
  * <br>- 200 (OK) with body {@link IdDTO}<br>- 401 (User is not authorized)<br>- 409 (User cannot be added to database as user with the specified name already exists)
  * <p></p>
  * @param requestParameters {@link CreateUserRequestParams}
  * @param requestOptions Optional request options
  */

    public createUser<T>(requestParameters: CreateUserRequestParams, requestOptions?: IRequestOptionsWithResponseType<T>): Observable<T>
    public createUser<T>(requestParameters: CreateUserRequestParams, requestOptions?: any): Observable<IdDTO> {
        if (!!requestOptions && !!requestOptions.debugging) {
            if (!!requestOptions.responseType) {
                this.logger.debug("Using extended DTO for deserialization");
            } else {
                this.logger.debug("No handwritten DTO extension was registered");
            }
            this.logger.debug("Sending request createUser with parameters", requestParameters);
        }

        const dto = requestParameters.dto;
        if (dto === null || dto === undefined) {
            this.logger.error('Required parameter dto was null or undefined when calling createUser.');
            throw new Error('Required parameter dto was null or undefined when calling createUser.');
        }

        let headers = this.defaultHeaders;

        // authentication (JWT) required
        if (this.configuration.apiKeys) {
            const key: string | undefined = this.configuration.apiKeys["JWT"] || this.configuration.apiKeys["Authorization"];
            if (key) {
                headers = headers.set('Authorization', key);
            }
        }
        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected  = this.configuration.selectHeaderAccept(httpHeaderAccepts);

        let acceptString = "application/json";
        if (httpHeaderAccepts.length > 0) {
            acceptString = httpHeaderAccepts.join(", ");
            if (httpHeaderAccepts.find((acceptString: string) => acceptString.includes("json")) === undefined) {
                acceptString += ", application/json";
            }
        }
        headers = headers.set('Accept', acceptString);

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        let responseType: 'text' | 'json' = 'json';
        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {
            responseType = 'text';
        }
        if(acceptString.includes('image')) {
            responseType = "blob" as "json";
        }


        const httpOptions: any = {
            responseType: <any>responseType,
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: (!!requestOptions && !!requestOptions.observe) ? requestOptions.observe : "body"
        };

        const requestPath = `${this.configuration.basePath}/users`;

        const logRequest: LogRequest = {
            url: requestPath,
            body: dto,
            headers
        };

        if (acceptString.includes('image')) {
            return this.httpClient.get<Blob>(requestPath, httpOptions as BlobOptions).pipe(
                concatMap(result => {
                    return this.createImageFromBlob(result);
                }),
                catchError(this.getErrorCallback(logRequest).bind(this))
            );
        } else if (!!requestOptions && !!requestOptions.responseType) {
            const responseObservable = this.httpClient.post<any>(requestPath ,dto,httpOptions).pipe(
                map(response => plainToClassFromExist(new requestOptions.responseType(), response)),
                catchError(this.getErrorCallback(logRequest).bind(this))
            );
            return responseObservable;
        } else {
            return this.httpClient.post<IdDTO>(requestPath, 
            dto,
                httpOptions
            ).pipe(
                catchError(this.getErrorCallback(logRequest).bind(this))
            );
        }
  }

    /**
  * Delete the specified user account
  * <p></p>
  * <p></p>
  * <b>Security @PreAuthorize expression:</b> <tt>hasRole(\'ADMIN\')</tt>
  * <p></p>
  * <p></p>
  * <b>Example Response:</b><br>
  * <pre>
  * {
  "type" : "OkDTO"
}
  * </pre>
  * <p></p>
  * <p><b>Possible HTTP Response Statuses:</b>
  * <br>- 200 (OK) with body {@link OkDTO}<br>- 401 (User is not authorized)<br>- 404 (User does not exist)
  * <p></p>
  * @param requestParameters {@link DeleteUserRequestParams}
  * @param requestOptions Optional request options
  */

    public deleteUser(requestParameters: DeleteUserRequestParams, requestOptions?: IRequestOptions): Observable<OkDTO>
    /**
  * Delete the specified user account
  * <p></p>
  * <p></p>
  * <b>Security @PreAuthorize expression:</b> <tt>hasRole(\'ADMIN\')</tt>
  * <p></p>
  * <p></p>
  * <b>Example Response:</b><br>
  * <pre>
  * {
  "type" : "OkDTO"
}
  * </pre>
  * <p></p>
  * <p><b>Possible HTTP Response Statuses:</b>
  * <br>- 200 (OK) with body {@link OkDTO}<br>- 401 (User is not authorized)<br>- 404 (User does not exist)
  * <p></p>
  * @param requestParameters {@link DeleteUserRequestParams}
  * @param requestOptions Optional request options
  */

    public deleteUser<T>(requestParameters: DeleteUserRequestParams, requestOptions?: IRequestOptionsWithResponseType<T>): Observable<T>
    public deleteUser<T>(requestParameters: DeleteUserRequestParams, requestOptions?: any): Observable<OkDTO> {
        if (!!requestOptions && !!requestOptions.debugging) {
            if (!!requestOptions.responseType) {
                this.logger.debug("Using extended DTO for deserialization");
            } else {
                this.logger.debug("No handwritten DTO extension was registered");
            }
            this.logger.debug("Sending request deleteUser with parameters", requestParameters);
        }

        const id = requestParameters.id;
        if (id === null || id === undefined) {
            this.logger.error('Required parameter id was null or undefined when calling deleteUser.');
            throw new Error('Required parameter id was null or undefined when calling deleteUser.');
        }

        let headers = this.defaultHeaders;

        // authentication (JWT) required
        if (this.configuration.apiKeys) {
            const key: string | undefined = this.configuration.apiKeys["JWT"] || this.configuration.apiKeys["Authorization"];
            if (key) {
                headers = headers.set('Authorization', key);
            }
        }
        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected  = this.configuration.selectHeaderAccept(httpHeaderAccepts);

        let acceptString = "application/json";
        if (httpHeaderAccepts.length > 0) {
            acceptString = httpHeaderAccepts.join(", ");
            if (httpHeaderAccepts.find((acceptString: string) => acceptString.includes("json")) === undefined) {
                acceptString += ", application/json";
            }
        }
        headers = headers.set('Accept', acceptString);


        let responseType: 'text' | 'json' = 'json';
        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {
            responseType = 'text';
        }
        if(acceptString.includes('image')) {
            responseType = "blob" as "json";
        }


        const httpOptions: any = {
            responseType: <any>responseType,
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: (!!requestOptions && !!requestOptions.observe) ? requestOptions.observe : "body"
        };

        const requestPath = `${this.configuration.basePath}/users/${encodeURIComponent(String(id))}`;

        const logRequest: LogRequest = {
            url: requestPath,
            
            headers
        };

        if (acceptString.includes('image')) {
            return this.httpClient.get<Blob>(requestPath, httpOptions as BlobOptions).pipe(
                concatMap(result => {
                    return this.createImageFromBlob(result);
                }),
                catchError(this.getErrorCallback(logRequest).bind(this))
            );
        } else if (!!requestOptions && !!requestOptions.responseType) {
            const responseObservable = this.httpClient.delete<any>(requestPath ,httpOptions).pipe(
                map(response => plainToClassFromExist(new requestOptions.responseType(), response)),
                catchError(this.getErrorCallback(logRequest).bind(this))
            );
            return responseObservable;
        } else {
            return this.httpClient.delete<OkDTO>(requestPath, 
                httpOptions
            ).pipe(
                catchError(this.getErrorCallback(logRequest).bind(this))
            );
        }
  }

    /**
  * Disable the specified user account
  * <p></p>
  * <p></p>
  * <b>Security @PreAuthorize expression:</b> <tt>hasRole(\'ADMIN\')</tt>
  * <p></p>
  * <p></p>
  * <b>Example Response:</b><br>
  * <pre>
  * {
  "type" : "OkDTO"
}
  * </pre>
  * <p></p>
  * <p><b>Possible HTTP Response Statuses:</b>
  * <br>- 200 (OK) with body {@link OkDTO}<br>- 401 (User is not authorized)<br>- 404 (User does not exist)
  * <p></p>
  * @param requestParameters {@link DisableUserRequestParams}
  * @param requestOptions Optional request options
  */

    public disableUser(requestParameters: DisableUserRequestParams, requestOptions?: IRequestOptions): Observable<OkDTO>
    /**
  * Disable the specified user account
  * <p></p>
  * <p></p>
  * <b>Security @PreAuthorize expression:</b> <tt>hasRole(\'ADMIN\')</tt>
  * <p></p>
  * <p></p>
  * <b>Example Response:</b><br>
  * <pre>
  * {
  "type" : "OkDTO"
}
  * </pre>
  * <p></p>
  * <p><b>Possible HTTP Response Statuses:</b>
  * <br>- 200 (OK) with body {@link OkDTO}<br>- 401 (User is not authorized)<br>- 404 (User does not exist)
  * <p></p>
  * @param requestParameters {@link DisableUserRequestParams}
  * @param requestOptions Optional request options
  */

    public disableUser<T>(requestParameters: DisableUserRequestParams, requestOptions?: IRequestOptionsWithResponseType<T>): Observable<T>
    public disableUser<T>(requestParameters: DisableUserRequestParams, requestOptions?: any): Observable<OkDTO> {
        if (!!requestOptions && !!requestOptions.debugging) {
            if (!!requestOptions.responseType) {
                this.logger.debug("Using extended DTO for deserialization");
            } else {
                this.logger.debug("No handwritten DTO extension was registered");
            }
            this.logger.debug("Sending request disableUser with parameters", requestParameters);
        }

        const id = requestParameters.id;
        if (id === null || id === undefined) {
            this.logger.error('Required parameter id was null or undefined when calling disableUser.');
            throw new Error('Required parameter id was null or undefined when calling disableUser.');
        }

        let headers = this.defaultHeaders;

        // authentication (JWT) required
        if (this.configuration.apiKeys) {
            const key: string | undefined = this.configuration.apiKeys["JWT"] || this.configuration.apiKeys["Authorization"];
            if (key) {
                headers = headers.set('Authorization', key);
            }
        }
        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected  = this.configuration.selectHeaderAccept(httpHeaderAccepts);

        let acceptString = "application/json";
        if (httpHeaderAccepts.length > 0) {
            acceptString = httpHeaderAccepts.join(", ");
            if (httpHeaderAccepts.find((acceptString: string) => acceptString.includes("json")) === undefined) {
                acceptString += ", application/json";
            }
        }
        headers = headers.set('Accept', acceptString);


        let responseType: 'text' | 'json' = 'json';
        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {
            responseType = 'text';
        }
        if(acceptString.includes('image')) {
            responseType = "blob" as "json";
        }


        const httpOptions: any = {
            responseType: <any>responseType,
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: (!!requestOptions && !!requestOptions.observe) ? requestOptions.observe : "body"
        };

        const requestPath = `${this.configuration.basePath}/users/disable/${encodeURIComponent(String(id))}`;

        const logRequest: LogRequest = {
            url: requestPath,
            
            headers
        };

        if (acceptString.includes('image')) {
            return this.httpClient.get<Blob>(requestPath, httpOptions as BlobOptions).pipe(
                concatMap(result => {
                    return this.createImageFromBlob(result);
                }),
                catchError(this.getErrorCallback(logRequest).bind(this))
            );
        } else if (!!requestOptions && !!requestOptions.responseType) {
            const responseObservable = this.httpClient.get<any>(requestPath ,httpOptions).pipe(
                map(response => plainToClassFromExist(new requestOptions.responseType(), response)),
                catchError(this.getErrorCallback(logRequest).bind(this))
            );
            return responseObservable;
        } else {
            return this.httpClient.get<OkDTO>(requestPath, 
                httpOptions
            ).pipe(
                catchError(this.getErrorCallback(logRequest).bind(this))
            );
        }
  }

    /**
  * Find profile image for the specified user
  * <p></p>
  * <p></p>
  * <b>Example Response:</b><br>
  * <pre>
  * 
  * </pre>
  * <p></p>
  * <p><b>Possible HTTP Response Statuses:</b>
  * <br>- 200 (OK)<br>- 401 (User is not authorized)<br>- 404 (User does not exist)
  * <p></p>
  * @param requestParameters {@link DownloadProfileImageRequestParams}
  * @param requestOptions Optional request options
  */

    public downloadProfileImage(requestParameters: DownloadProfileImageRequestParams, requestOptions?: IRequestOptions): Observable<any>
    /**
  * Find profile image for the specified user
  * <p></p>
  * <p></p>
  * <b>Example Response:</b><br>
  * <pre>
  * 
  * </pre>
  * <p></p>
  * <p><b>Possible HTTP Response Statuses:</b>
  * <br>- 200 (OK)<br>- 401 (User is not authorized)<br>- 404 (User does not exist)
  * <p></p>
  * @param requestParameters {@link DownloadProfileImageRequestParams}
  * @param requestOptions Optional request options
  */

    public downloadProfileImage<T>(requestParameters: DownloadProfileImageRequestParams, requestOptions?: IRequestOptionsWithResponseType<T>): Observable<T>
    public downloadProfileImage<T>(requestParameters: DownloadProfileImageRequestParams, requestOptions?: any): Observable<any> {
        if (!!requestOptions && !!requestOptions.debugging) {
            if (!!requestOptions.responseType) {
                this.logger.debug("Using extended DTO for deserialization");
            } else {
                this.logger.debug("No handwritten DTO extension was registered");
            }
            this.logger.debug("Sending request downloadProfileImage with parameters", requestParameters);
        }

        const id = requestParameters.id;
        if (id === null || id === undefined) {
            this.logger.error('Required parameter id was null or undefined when calling downloadProfileImage.');
            throw new Error('Required parameter id was null or undefined when calling downloadProfileImage.');
        }
        const thumbnail = requestParameters.thumbnail;

        let queryParameters = new HttpParams({encoder: this.encoder});
        if (thumbnail !== undefined && thumbnail !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>thumbnail, 'thumbnail');
        }

        let headers = this.defaultHeaders;

        // authentication (JWT) required
        if (this.configuration.apiKeys) {
            const key: string | undefined = this.configuration.apiKeys["JWT"] || this.configuration.apiKeys["Authorization"];
            if (key) {
                headers = headers.set('Authorization', key);
            }
        }
        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'image/jpeg',
            'application/json'
        ];
        let httpHeaderAcceptSelected  = this.configuration.selectHeaderAccept(httpHeaderAccepts);

        let acceptString = "application/json";
        if (httpHeaderAccepts.length > 0) {
            acceptString = httpHeaderAccepts.join(", ");
            if (httpHeaderAccepts.find((acceptString: string) => acceptString.includes("json")) === undefined) {
                acceptString += ", application/json";
            }
        }
        headers = headers.set('Accept', acceptString);


        let responseType: 'text' | 'json' = 'json';
        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {
            responseType = 'text';
        }
        if(acceptString.includes('image')) {
            responseType = "blob" as "json";
        }


        const httpOptions: any = {
            params: queryParameters,
            responseType: <any>responseType,
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: (!!requestOptions && !!requestOptions.observe) ? requestOptions.observe : "body"
        };

        const requestPath = `${this.configuration.basePath}/users/${encodeURIComponent(String(id))}/image`;

        const logRequest: LogRequest = {
            url: requestPath,
            
            headers
        };

        if (acceptString.includes('image')) {
            return this.httpClient.get<Blob>(requestPath, httpOptions as BlobOptions).pipe(
                concatMap(result => {
                    return this.createImageFromBlob(result);
                }),
                catchError(this.getErrorCallback(logRequest).bind(this))
            );
        } else if (!!requestOptions && !!requestOptions.responseType) {
            const responseObservable = this.httpClient.get<any>(requestPath ,httpOptions).pipe(
                map(response => plainToClassFromExist(new requestOptions.responseType(), response)),
                catchError(this.getErrorCallback(logRequest).bind(this))
            );
            return responseObservable;
        } else {
            return this.httpClient.get<any>(requestPath, 
                httpOptions
            ).pipe(
                catchError(this.getErrorCallback(logRequest).bind(this))
            );
        }
  }

    /**
  * Enable the specified user account
  * <p></p>
  * <p></p>
  * <b>Security @PreAuthorize expression:</b> <tt>hasRole(\'ADMIN\')</tt>
  * <p></p>
  * <p></p>
  * <b>Example Response:</b><br>
  * <pre>
  * {
  "type" : "OkDTO"
}
  * </pre>
  * <p></p>
  * <p><b>Possible HTTP Response Statuses:</b>
  * <br>- 200 (OK) with body {@link OkDTO}<br>- 401 (User is not authorized)<br>- 404 (User does not exist)
  * <p></p>
  * @param requestParameters {@link EnableUserRequestParams}
  * @param requestOptions Optional request options
  */

    public enableUser(requestParameters: EnableUserRequestParams, requestOptions?: IRequestOptions): Observable<OkDTO>
    /**
  * Enable the specified user account
  * <p></p>
  * <p></p>
  * <b>Security @PreAuthorize expression:</b> <tt>hasRole(\'ADMIN\')</tt>
  * <p></p>
  * <p></p>
  * <b>Example Response:</b><br>
  * <pre>
  * {
  "type" : "OkDTO"
}
  * </pre>
  * <p></p>
  * <p><b>Possible HTTP Response Statuses:</b>
  * <br>- 200 (OK) with body {@link OkDTO}<br>- 401 (User is not authorized)<br>- 404 (User does not exist)
  * <p></p>
  * @param requestParameters {@link EnableUserRequestParams}
  * @param requestOptions Optional request options
  */

    public enableUser<T>(requestParameters: EnableUserRequestParams, requestOptions?: IRequestOptionsWithResponseType<T>): Observable<T>
    public enableUser<T>(requestParameters: EnableUserRequestParams, requestOptions?: any): Observable<OkDTO> {
        if (!!requestOptions && !!requestOptions.debugging) {
            if (!!requestOptions.responseType) {
                this.logger.debug("Using extended DTO for deserialization");
            } else {
                this.logger.debug("No handwritten DTO extension was registered");
            }
            this.logger.debug("Sending request enableUser with parameters", requestParameters);
        }

        const id = requestParameters.id;
        if (id === null || id === undefined) {
            this.logger.error('Required parameter id was null or undefined when calling enableUser.');
            throw new Error('Required parameter id was null or undefined when calling enableUser.');
        }

        let headers = this.defaultHeaders;

        // authentication (JWT) required
        if (this.configuration.apiKeys) {
            const key: string | undefined = this.configuration.apiKeys["JWT"] || this.configuration.apiKeys["Authorization"];
            if (key) {
                headers = headers.set('Authorization', key);
            }
        }
        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected  = this.configuration.selectHeaderAccept(httpHeaderAccepts);

        let acceptString = "application/json";
        if (httpHeaderAccepts.length > 0) {
            acceptString = httpHeaderAccepts.join(", ");
            if (httpHeaderAccepts.find((acceptString: string) => acceptString.includes("json")) === undefined) {
                acceptString += ", application/json";
            }
        }
        headers = headers.set('Accept', acceptString);


        let responseType: 'text' | 'json' = 'json';
        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {
            responseType = 'text';
        }
        if(acceptString.includes('image')) {
            responseType = "blob" as "json";
        }


        const httpOptions: any = {
            responseType: <any>responseType,
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: (!!requestOptions && !!requestOptions.observe) ? requestOptions.observe : "body"
        };

        const requestPath = `${this.configuration.basePath}/users/enable/${encodeURIComponent(String(id))}`;

        const logRequest: LogRequest = {
            url: requestPath,
            
            headers
        };

        if (acceptString.includes('image')) {
            return this.httpClient.get<Blob>(requestPath, httpOptions as BlobOptions).pipe(
                concatMap(result => {
                    return this.createImageFromBlob(result);
                }),
                catchError(this.getErrorCallback(logRequest).bind(this))
            );
        } else if (!!requestOptions && !!requestOptions.responseType) {
            const responseObservable = this.httpClient.get<any>(requestPath ,httpOptions).pipe(
                map(response => plainToClassFromExist(new requestOptions.responseType(), response)),
                catchError(this.getErrorCallback(logRequest).bind(this))
            );
            return responseObservable;
        } else {
            return this.httpClient.get<OkDTO>(requestPath, 
                httpOptions
            ).pipe(
                catchError(this.getErrorCallback(logRequest).bind(this))
            );
        }
  }

    /**
  * Find all users
  * <p></p>
  * <p></p>
  * <b>Security @PreAuthorize expression:</b> <tt>hasRole(\'ADMIN\')</tt>
  * <p></p>
  * <p></p>
  * <b>Example Response:</b><br>
  * <pre>
  * {
  "users" : [ {
    "firstname" : "Miguel",
    "disabled" : true,
    "id" : 0,
    "email" : "a@b.com",
    "activated" : true,
    "lastname" : "Franken",
    "username" : "miguel.franken"
  }, {
    "firstname" : "Miguel",
    "disabled" : true,
    "id" : 0,
    "email" : "a@b.com",
    "activated" : true,
    "lastname" : "Franken",
    "username" : "miguel.franken"
  } ]
}
  * </pre>
  * <p></p>
  * <p><b>Possible HTTP Response Statuses:</b>
  * <br>- 200 (OK) with body {@link UserListDTO}<br>- 401 (User is not authorized)
  * <p></p>
  * @param requestOptions Optional request options
  */

    public findAllUsers(requestOptions?: IRequestOptions): Observable<UserListDTO>
    /**
  * Find all users
  * <p></p>
  * <p></p>
  * <b>Security @PreAuthorize expression:</b> <tt>hasRole(\'ADMIN\')</tt>
  * <p></p>
  * <p></p>
  * <b>Example Response:</b><br>
  * <pre>
  * {
  "users" : [ {
    "firstname" : "Miguel",
    "disabled" : true,
    "id" : 0,
    "email" : "a@b.com",
    "activated" : true,
    "lastname" : "Franken",
    "username" : "miguel.franken"
  }, {
    "firstname" : "Miguel",
    "disabled" : true,
    "id" : 0,
    "email" : "a@b.com",
    "activated" : true,
    "lastname" : "Franken",
    "username" : "miguel.franken"
  } ]
}
  * </pre>
  * <p></p>
  * <p><b>Possible HTTP Response Statuses:</b>
  * <br>- 200 (OK) with body {@link UserListDTO}<br>- 401 (User is not authorized)
  * <p></p>
  * @param requestOptions Optional request options
  */

    public findAllUsers<T>(requestOptions?: IRequestOptionsWithResponseType<T>): Observable<T>
    public findAllUsers<T>(requestOptions?: any): Observable<UserListDTO> {
        if (!!requestOptions && !!requestOptions.debugging) {
            if (!!requestOptions.responseType) {
                this.logger.debug("Using extended DTO for deserialization");
            } else {
                this.logger.debug("No handwritten DTO extension was registered");
            }
            this.logger.debug("Sending request findAllUsers");
        }


        let headers = this.defaultHeaders;

        // authentication (JWT) required
        if (this.configuration.apiKeys) {
            const key: string | undefined = this.configuration.apiKeys["JWT"] || this.configuration.apiKeys["Authorization"];
            if (key) {
                headers = headers.set('Authorization', key);
            }
        }
        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected  = this.configuration.selectHeaderAccept(httpHeaderAccepts);

        let acceptString = "application/json";
        if (httpHeaderAccepts.length > 0) {
            acceptString = httpHeaderAccepts.join(", ");
            if (httpHeaderAccepts.find((acceptString: string) => acceptString.includes("json")) === undefined) {
                acceptString += ", application/json";
            }
        }
        headers = headers.set('Accept', acceptString);


        let responseType: 'text' | 'json' = 'json';
        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {
            responseType = 'text';
        }
        if(acceptString.includes('image')) {
            responseType = "blob" as "json";
        }


        const httpOptions: any = {
            responseType: <any>responseType,
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: (!!requestOptions && !!requestOptions.observe) ? requestOptions.observe : "body"
        };

        const requestPath = `${this.configuration.basePath}/users`;

        const logRequest: LogRequest = {
            url: requestPath,
            
            headers
        };

        if (acceptString.includes('image')) {
            return this.httpClient.get<Blob>(requestPath, httpOptions as BlobOptions).pipe(
                concatMap(result => {
                    return this.createImageFromBlob(result);
                }),
                catchError(this.getErrorCallback(logRequest).bind(this))
            );
        } else if (!!requestOptions && !!requestOptions.responseType) {
            const responseObservable = this.httpClient.get<any>(requestPath ,httpOptions).pipe(
                map(response => plainToClassFromExist(new requestOptions.responseType(), response)),
                catchError(this.getErrorCallback(logRequest).bind(this))
            );
            return responseObservable;
        } else {
            return this.httpClient.get<UserListDTO>(requestPath, 
                httpOptions
            ).pipe(
                catchError(this.getErrorCallback(logRequest).bind(this))
            );
        }
  }

    /**
  * Upload new profile image for the specified user
  * <p></p>
  * <p></p>
  * <b>Example Response:</b><br>
  * <pre>
  * {
  "type" : "OkDTO"
}
  * </pre>
  * <p></p>
  * <p><b>Possible HTTP Response Statuses:</b>
  * <br>- 200 (OK) with body {@link OkDTO}<br>- 401 (User is not authorized)
  * <p></p>
  * @param requestParameters {@link UploadProfileImageRequestParams}
  * @param requestOptions Optional request options
  */

    public uploadProfileImage(requestParameters: UploadProfileImageRequestParams, requestOptions?: IRequestOptions): Observable<OkDTO>
    /**
  * Upload new profile image for the specified user
  * <p></p>
  * <p></p>
  * <b>Example Response:</b><br>
  * <pre>
  * {
  "type" : "OkDTO"
}
  * </pre>
  * <p></p>
  * <p><b>Possible HTTP Response Statuses:</b>
  * <br>- 200 (OK) with body {@link OkDTO}<br>- 401 (User is not authorized)
  * <p></p>
  * @param requestParameters {@link UploadProfileImageRequestParams}
  * @param requestOptions Optional request options
  */

    public uploadProfileImage<T>(requestParameters: UploadProfileImageRequestParams, requestOptions?: IRequestOptionsWithResponseType<T>): Observable<T>
    public uploadProfileImage<T>(requestParameters: UploadProfileImageRequestParams, requestOptions?: any): Observable<OkDTO> {
        if (!!requestOptions && !!requestOptions.debugging) {
            if (!!requestOptions.responseType) {
                this.logger.debug("Using extended DTO for deserialization");
            } else {
                this.logger.debug("No handwritten DTO extension was registered");
            }
            this.logger.debug("Sending request uploadProfileImage with parameters", requestParameters);
        }

        const id = requestParameters.id;
        if (id === null || id === undefined) {
            this.logger.error('Required parameter id was null or undefined when calling uploadProfileImage.');
            throw new Error('Required parameter id was null or undefined when calling uploadProfileImage.');
        }
        const image = requestParameters.image;
        if (image === null || image === undefined) {
            this.logger.error('Required parameter image was null or undefined when calling uploadProfileImage.');
            throw new Error('Required parameter image was null or undefined when calling uploadProfileImage.');
        }

        let headers = this.defaultHeaders;

        // authentication (JWT) required
        if (this.configuration.apiKeys) {
            const key: string | undefined = this.configuration.apiKeys["JWT"] || this.configuration.apiKeys["Authorization"];
            if (key) {
                headers = headers.set('Authorization', key);
            }
        }
        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected  = this.configuration.selectHeaderAccept(httpHeaderAccepts);

        let acceptString = "application/json";
        if (httpHeaderAccepts.length > 0) {
            acceptString = httpHeaderAccepts.join(", ");
            if (httpHeaderAccepts.find((acceptString: string) => acceptString.includes("json")) === undefined) {
                acceptString += ", application/json";
            }
        }
        headers = headers.set('Accept', acceptString);

        // to determine the Content-Type header
        const consumes: string[] = [
            'multipart/form-data'
        ];

        const canConsumeForm = this.canConsumeForm(consumes);

        let formParams: { append(param: string, value: any): any; };
        let useForm = false;
        let convertFormParamsToString = false;
        // use FormData to transmit files using content-type "multipart/form-data"
        // see https://stackoverflow.com/questions/4007969/application-x-www-form-urlencoded-or-multipart-form-data
        useForm = canConsumeForm;
        if (useForm) {
            formParams = new FormData();
        } else {
            formParams = new HttpParams({encoder: this.encoder});
        }

        if (image !== undefined) {
            formParams = formParams.append('image', <any>image) as any || formParams;
        }

        let responseType: 'text' | 'json' = 'json';
        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {
            responseType = 'text';
        }
        if(acceptString.includes('image')) {
            responseType = "blob" as "json";
        }


        const httpOptions: any = {
            responseType: <any>responseType,
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: (!!requestOptions && !!requestOptions.observe) ? requestOptions.observe : "body"
        };

        const requestPath = `${this.configuration.basePath}/users/${encodeURIComponent(String(id))}/image`;

        const logRequest: LogRequest = {
            url: requestPath,
            body: convertFormParamsToString ? formParams.toString() : formParams,
            headers
        };

        if (acceptString.includes('image')) {
            return this.httpClient.get<Blob>(requestPath, httpOptions as BlobOptions).pipe(
                concatMap(result => {
                    return this.createImageFromBlob(result);
                }),
                catchError(this.getErrorCallback(logRequest).bind(this))
            );
        } else if (!!requestOptions && !!requestOptions.responseType) {
            const responseObservable = this.httpClient.post<any>(requestPath ,convertFormParamsToString ? formParams.toString() : formParams,httpOptions).pipe(
                map(response => plainToClassFromExist(new requestOptions.responseType(), response)),
                catchError(this.getErrorCallback(logRequest).bind(this))
            );
            return responseObservable;
        } else {
            return this.httpClient.post<OkDTO>(requestPath, 
            convertFormParamsToString ? formParams.toString() : formParams,
                httpOptions
            ).pipe(
                catchError(this.getErrorCallback(logRequest).bind(this))
            );
        }
  }

}
